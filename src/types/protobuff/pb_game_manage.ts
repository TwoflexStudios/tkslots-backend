// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.8.3
//   protoc               v6.33.0
// source: pb_game_manage.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";

export const protobufPackage = "pb_game_manage";

export interface csRoomLogon {
  nameID: number;
  userID: number;
  roomVer: number;
  gameVer: number;
  md5Pass: string;
  session: string;
}

export interface scRoomLogonResult {
  userID: number;
  point: number;
  money: number;
  bank: number;
  logoID: number;
  deskNo: number;
  deskStation: number;
  userState: number;
  nickName: string;
}

export interface csGameSwitchBet {
  score: number;
}

export interface scGameSwitchBet {
  code: number;
}

export interface scGameInfo {
  deskNo: number;
  deskStation: number;
  money: number;
  betScore: number;
}

export interface notifyUserInfo {
  userID: number;
  point: number;
  money: number;
  bank: number;
  logoID: number;
  deskNo: number;
  deskStation: number;
  userState: number;
  nickName: string;
  loginIP: number;
}

export interface notifyDeskPlayers {
  list: notifyUserInfo[];
}

export interface notifyGameJackpot {
  gameId: number;
  jackpot: number;
}

export interface notifyGameWinScoreNoticeMsg {
  type: number;
  userName: string;
  gameName: string;
  winScore: number;
  logo: number;
  timestamp: number;
  multiple: number;
  roomId: number;
  gameId: number;
  viplv: number;
}

export interface notifyGameGradeInfo {
  scoreList: number[];
}

export interface notifyUserinfoUpdate {
  money: number;
  bank: number;
  vipLevel: number;
  vipExp: number;
  name: string;
  logoId: number;
  type: number;
  changed: number;
  phoneNo: string;
  areaCode: string;
}

export interface scJackpotWinnerList {
  winners: notifyGameWinScoreNoticeMsg[];
}

export interface scBetForbidMsg {
  forbid: number;
}

export interface notifyKickWarnMsg {
  param: number;
}

export interface notifyUserRechargeResultInfo {
  firstRecharge: number;
  rechargeCoins: number;
  rechargeCash: number;
}

export interface scNoticeMarquee {
  noticelist: notifyGameWinScoreNoticeMsg[];
}

export interface scOtherUserSit {
  userID: number;
  deskNo: number;
  deskStation: number;
  nickName: string;
  logoID: number;
}

export interface scOtherUserCut {
  userID: number;
  deskNo: number;
}

function createBasecsRoomLogon(): csRoomLogon {
  return { nameID: 0, userID: 0, roomVer: 0, gameVer: 0, md5Pass: "", session: "" };
}

export const csRoomLogon: MessageFns<csRoomLogon> = {
  encode(message: csRoomLogon, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.nameID !== 0) {
      writer.uint32(8).int32(message.nameID);
    }
    if (message.userID !== 0) {
      writer.uint32(16).int32(message.userID);
    }
    if (message.roomVer !== 0) {
      writer.uint32(24).int32(message.roomVer);
    }
    if (message.gameVer !== 0) {
      writer.uint32(32).int32(message.gameVer);
    }
    if (message.md5Pass !== "") {
      writer.uint32(42).string(message.md5Pass);
    }
    if (message.session !== "") {
      writer.uint32(50).string(message.session);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): csRoomLogon {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasecsRoomLogon();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.nameID = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.userID = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.roomVer = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.gameVer = reader.int32();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.md5Pass = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.session = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): csRoomLogon {
    return {
      nameID: isSet(object.nameID) ? globalThis.Number(object.nameID) : 0,
      userID: isSet(object.userID) ? globalThis.Number(object.userID) : 0,
      roomVer: isSet(object.roomVer) ? globalThis.Number(object.roomVer) : 0,
      gameVer: isSet(object.gameVer) ? globalThis.Number(object.gameVer) : 0,
      md5Pass: isSet(object.md5Pass) ? globalThis.String(object.md5Pass) : "",
      session: isSet(object.session) ? globalThis.String(object.session) : "",
    };
  },

  toJSON(message: csRoomLogon): unknown {
    const obj: any = {};
    if (message.nameID !== 0) {
      obj.nameID = Math.round(message.nameID);
    }
    if (message.userID !== 0) {
      obj.userID = Math.round(message.userID);
    }
    if (message.roomVer !== 0) {
      obj.roomVer = Math.round(message.roomVer);
    }
    if (message.gameVer !== 0) {
      obj.gameVer = Math.round(message.gameVer);
    }
    if (message.md5Pass !== "") {
      obj.md5Pass = message.md5Pass;
    }
    if (message.session !== "") {
      obj.session = message.session;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<csRoomLogon>, I>>(base?: I): csRoomLogon {
    return csRoomLogon.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<csRoomLogon>, I>>(object: I): csRoomLogon {
    const message = createBasecsRoomLogon();
    message.nameID = object.nameID ?? 0;
    message.userID = object.userID ?? 0;
    message.roomVer = object.roomVer ?? 0;
    message.gameVer = object.gameVer ?? 0;
    message.md5Pass = object.md5Pass ?? "";
    message.session = object.session ?? "";
    return message;
  },
};

function createBasescRoomLogonResult(): scRoomLogonResult {
  return { userID: 0, point: 0, money: 0, bank: 0, logoID: 0, deskNo: 0, deskStation: 0, userState: 0, nickName: "" };
}

export const scRoomLogonResult: MessageFns<scRoomLogonResult> = {
  encode(message: scRoomLogonResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userID !== 0) {
      writer.uint32(8).int32(message.userID);
    }
    if (message.point !== 0) {
      writer.uint32(16).int32(message.point);
    }
    if (message.money !== 0) {
      writer.uint32(24).int64(message.money);
    }
    if (message.bank !== 0) {
      writer.uint32(32).int64(message.bank);
    }
    if (message.logoID !== 0) {
      writer.uint32(40).int32(message.logoID);
    }
    if (message.deskNo !== 0) {
      writer.uint32(48).int32(message.deskNo);
    }
    if (message.deskStation !== 0) {
      writer.uint32(56).int32(message.deskStation);
    }
    if (message.userState !== 0) {
      writer.uint32(64).int32(message.userState);
    }
    if (message.nickName !== "") {
      writer.uint32(74).string(message.nickName);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): scRoomLogonResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasescRoomLogonResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.userID = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.point = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.money = longToNumber(reader.int64());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.bank = longToNumber(reader.int64());
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.logoID = reader.int32();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.deskNo = reader.int32();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.deskStation = reader.int32();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.userState = reader.int32();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.nickName = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): scRoomLogonResult {
    return {
      userID: isSet(object.userID) ? globalThis.Number(object.userID) : 0,
      point: isSet(object.point) ? globalThis.Number(object.point) : 0,
      money: isSet(object.money) ? globalThis.Number(object.money) : 0,
      bank: isSet(object.bank) ? globalThis.Number(object.bank) : 0,
      logoID: isSet(object.logoID) ? globalThis.Number(object.logoID) : 0,
      deskNo: isSet(object.deskNo) ? globalThis.Number(object.deskNo) : 0,
      deskStation: isSet(object.deskStation) ? globalThis.Number(object.deskStation) : 0,
      userState: isSet(object.userState) ? globalThis.Number(object.userState) : 0,
      nickName: isSet(object.nickName) ? globalThis.String(object.nickName) : "",
    };
  },

  toJSON(message: scRoomLogonResult): unknown {
    const obj: any = {};
    if (message.userID !== 0) {
      obj.userID = Math.round(message.userID);
    }
    if (message.point !== 0) {
      obj.point = Math.round(message.point);
    }
    if (message.money !== 0) {
      obj.money = Math.round(message.money);
    }
    if (message.bank !== 0) {
      obj.bank = Math.round(message.bank);
    }
    if (message.logoID !== 0) {
      obj.logoID = Math.round(message.logoID);
    }
    if (message.deskNo !== 0) {
      obj.deskNo = Math.round(message.deskNo);
    }
    if (message.deskStation !== 0) {
      obj.deskStation = Math.round(message.deskStation);
    }
    if (message.userState !== 0) {
      obj.userState = Math.round(message.userState);
    }
    if (message.nickName !== "") {
      obj.nickName = message.nickName;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<scRoomLogonResult>, I>>(base?: I): scRoomLogonResult {
    return scRoomLogonResult.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<scRoomLogonResult>, I>>(object: I): scRoomLogonResult {
    const message = createBasescRoomLogonResult();
    message.userID = object.userID ?? 0;
    message.point = object.point ?? 0;
    message.money = object.money ?? 0;
    message.bank = object.bank ?? 0;
    message.logoID = object.logoID ?? 0;
    message.deskNo = object.deskNo ?? 0;
    message.deskStation = object.deskStation ?? 0;
    message.userState = object.userState ?? 0;
    message.nickName = object.nickName ?? "";
    return message;
  },
};

function createBasecsGameSwitchBet(): csGameSwitchBet {
  return { score: 0 };
}

export const csGameSwitchBet: MessageFns<csGameSwitchBet> = {
  encode(message: csGameSwitchBet, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.score !== 0) {
      writer.uint32(8).int32(message.score);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): csGameSwitchBet {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasecsGameSwitchBet();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.score = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): csGameSwitchBet {
    return { score: isSet(object.score) ? globalThis.Number(object.score) : 0 };
  },

  toJSON(message: csGameSwitchBet): unknown {
    const obj: any = {};
    if (message.score !== 0) {
      obj.score = Math.round(message.score);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<csGameSwitchBet>, I>>(base?: I): csGameSwitchBet {
    return csGameSwitchBet.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<csGameSwitchBet>, I>>(object: I): csGameSwitchBet {
    const message = createBasecsGameSwitchBet();
    message.score = object.score ?? 0;
    return message;
  },
};

function createBasescGameSwitchBet(): scGameSwitchBet {
  return { code: 0 };
}

export const scGameSwitchBet: MessageFns<scGameSwitchBet> = {
  encode(message: scGameSwitchBet, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.code !== 0) {
      writer.uint32(8).int32(message.code);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): scGameSwitchBet {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasescGameSwitchBet();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.code = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): scGameSwitchBet {
    return { code: isSet(object.code) ? globalThis.Number(object.code) : 0 };
  },

  toJSON(message: scGameSwitchBet): unknown {
    const obj: any = {};
    if (message.code !== 0) {
      obj.code = Math.round(message.code);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<scGameSwitchBet>, I>>(base?: I): scGameSwitchBet {
    return scGameSwitchBet.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<scGameSwitchBet>, I>>(object: I): scGameSwitchBet {
    const message = createBasescGameSwitchBet();
    message.code = object.code ?? 0;
    return message;
  },
};

function createBasescGameInfo(): scGameInfo {
  return { deskNo: 0, deskStation: 0, money: 0, betScore: 0 };
}

export const scGameInfo: MessageFns<scGameInfo> = {
  encode(message: scGameInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.deskNo !== 0) {
      writer.uint32(8).int32(message.deskNo);
    }
    if (message.deskStation !== 0) {
      writer.uint32(16).int32(message.deskStation);
    }
    if (message.money !== 0) {
      writer.uint32(24).int64(message.money);
    }
    if (message.betScore !== 0) {
      writer.uint32(32).int32(message.betScore);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): scGameInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasescGameInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.deskNo = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.deskStation = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.money = longToNumber(reader.int64());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.betScore = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): scGameInfo {
    return {
      deskNo: isSet(object.deskNo) ? globalThis.Number(object.deskNo) : 0,
      deskStation: isSet(object.deskStation) ? globalThis.Number(object.deskStation) : 0,
      money: isSet(object.money) ? globalThis.Number(object.money) : 0,
      betScore: isSet(object.betScore) ? globalThis.Number(object.betScore) : 0,
    };
  },

  toJSON(message: scGameInfo): unknown {
    const obj: any = {};
    if (message.deskNo !== 0) {
      obj.deskNo = Math.round(message.deskNo);
    }
    if (message.deskStation !== 0) {
      obj.deskStation = Math.round(message.deskStation);
    }
    if (message.money !== 0) {
      obj.money = Math.round(message.money);
    }
    if (message.betScore !== 0) {
      obj.betScore = Math.round(message.betScore);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<scGameInfo>, I>>(base?: I): scGameInfo {
    return scGameInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<scGameInfo>, I>>(object: I): scGameInfo {
    const message = createBasescGameInfo();
    message.deskNo = object.deskNo ?? 0;
    message.deskStation = object.deskStation ?? 0;
    message.money = object.money ?? 0;
    message.betScore = object.betScore ?? 0;
    return message;
  },
};

function createBasenotifyUserInfo(): notifyUserInfo {
  return {
    userID: 0,
    point: 0,
    money: 0,
    bank: 0,
    logoID: 0,
    deskNo: 0,
    deskStation: 0,
    userState: 0,
    nickName: "",
    loginIP: 0,
  };
}

export const notifyUserInfo: MessageFns<notifyUserInfo> = {
  encode(message: notifyUserInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userID !== 0) {
      writer.uint32(8).int32(message.userID);
    }
    if (message.point !== 0) {
      writer.uint32(16).int32(message.point);
    }
    if (message.money !== 0) {
      writer.uint32(24).int64(message.money);
    }
    if (message.bank !== 0) {
      writer.uint32(32).int64(message.bank);
    }
    if (message.logoID !== 0) {
      writer.uint32(40).int32(message.logoID);
    }
    if (message.deskNo !== 0) {
      writer.uint32(48).int32(message.deskNo);
    }
    if (message.deskStation !== 0) {
      writer.uint32(56).int32(message.deskStation);
    }
    if (message.userState !== 0) {
      writer.uint32(64).int32(message.userState);
    }
    if (message.nickName !== "") {
      writer.uint32(74).string(message.nickName);
    }
    if (message.loginIP !== 0) {
      writer.uint32(80).int64(message.loginIP);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): notifyUserInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasenotifyUserInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.userID = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.point = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.money = longToNumber(reader.int64());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.bank = longToNumber(reader.int64());
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.logoID = reader.int32();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.deskNo = reader.int32();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.deskStation = reader.int32();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.userState = reader.int32();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.nickName = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.loginIP = longToNumber(reader.int64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): notifyUserInfo {
    return {
      userID: isSet(object.userID) ? globalThis.Number(object.userID) : 0,
      point: isSet(object.point) ? globalThis.Number(object.point) : 0,
      money: isSet(object.money) ? globalThis.Number(object.money) : 0,
      bank: isSet(object.bank) ? globalThis.Number(object.bank) : 0,
      logoID: isSet(object.logoID) ? globalThis.Number(object.logoID) : 0,
      deskNo: isSet(object.deskNo) ? globalThis.Number(object.deskNo) : 0,
      deskStation: isSet(object.deskStation) ? globalThis.Number(object.deskStation) : 0,
      userState: isSet(object.userState) ? globalThis.Number(object.userState) : 0,
      nickName: isSet(object.nickName) ? globalThis.String(object.nickName) : "",
      loginIP: isSet(object.loginIP) ? globalThis.Number(object.loginIP) : 0,
    };
  },

  toJSON(message: notifyUserInfo): unknown {
    const obj: any = {};
    if (message.userID !== 0) {
      obj.userID = Math.round(message.userID);
    }
    if (message.point !== 0) {
      obj.point = Math.round(message.point);
    }
    if (message.money !== 0) {
      obj.money = Math.round(message.money);
    }
    if (message.bank !== 0) {
      obj.bank = Math.round(message.bank);
    }
    if (message.logoID !== 0) {
      obj.logoID = Math.round(message.logoID);
    }
    if (message.deskNo !== 0) {
      obj.deskNo = Math.round(message.deskNo);
    }
    if (message.deskStation !== 0) {
      obj.deskStation = Math.round(message.deskStation);
    }
    if (message.userState !== 0) {
      obj.userState = Math.round(message.userState);
    }
    if (message.nickName !== "") {
      obj.nickName = message.nickName;
    }
    if (message.loginIP !== 0) {
      obj.loginIP = Math.round(message.loginIP);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<notifyUserInfo>, I>>(base?: I): notifyUserInfo {
    return notifyUserInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<notifyUserInfo>, I>>(object: I): notifyUserInfo {
    const message = createBasenotifyUserInfo();
    message.userID = object.userID ?? 0;
    message.point = object.point ?? 0;
    message.money = object.money ?? 0;
    message.bank = object.bank ?? 0;
    message.logoID = object.logoID ?? 0;
    message.deskNo = object.deskNo ?? 0;
    message.deskStation = object.deskStation ?? 0;
    message.userState = object.userState ?? 0;
    message.nickName = object.nickName ?? "";
    message.loginIP = object.loginIP ?? 0;
    return message;
  },
};

function createBasenotifyDeskPlayers(): notifyDeskPlayers {
  return { list: [] };
}

export const notifyDeskPlayers: MessageFns<notifyDeskPlayers> = {
  encode(message: notifyDeskPlayers, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.list) {
      notifyUserInfo.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): notifyDeskPlayers {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasenotifyDeskPlayers();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.list.push(notifyUserInfo.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): notifyDeskPlayers {
    return {
      list: globalThis.Array.isArray(object?.list) ? object.list.map((e: any) => notifyUserInfo.fromJSON(e)) : [],
    };
  },

  toJSON(message: notifyDeskPlayers): unknown {
    const obj: any = {};
    if (message.list?.length) {
      obj.list = message.list.map((e) => notifyUserInfo.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<notifyDeskPlayers>, I>>(base?: I): notifyDeskPlayers {
    return notifyDeskPlayers.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<notifyDeskPlayers>, I>>(object: I): notifyDeskPlayers {
    const message = createBasenotifyDeskPlayers();
    message.list = object.list?.map((e) => notifyUserInfo.fromPartial(e)) || [];
    return message;
  },
};

function createBasenotifyGameJackpot(): notifyGameJackpot {
  return { gameId: 0, jackpot: 0 };
}

export const notifyGameJackpot: MessageFns<notifyGameJackpot> = {
  encode(message: notifyGameJackpot, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.gameId !== 0) {
      writer.uint32(8).int32(message.gameId);
    }
    if (message.jackpot !== 0) {
      writer.uint32(16).int64(message.jackpot);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): notifyGameJackpot {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasenotifyGameJackpot();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.gameId = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.jackpot = longToNumber(reader.int64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): notifyGameJackpot {
    return {
      gameId: isSet(object.gameId) ? globalThis.Number(object.gameId) : 0,
      jackpot: isSet(object.jackpot) ? globalThis.Number(object.jackpot) : 0,
    };
  },

  toJSON(message: notifyGameJackpot): unknown {
    const obj: any = {};
    if (message.gameId !== 0) {
      obj.gameId = Math.round(message.gameId);
    }
    if (message.jackpot !== 0) {
      obj.jackpot = Math.round(message.jackpot);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<notifyGameJackpot>, I>>(base?: I): notifyGameJackpot {
    return notifyGameJackpot.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<notifyGameJackpot>, I>>(object: I): notifyGameJackpot {
    const message = createBasenotifyGameJackpot();
    message.gameId = object.gameId ?? 0;
    message.jackpot = object.jackpot ?? 0;
    return message;
  },
};

function createBasenotifyGameWinScoreNoticeMsg(): notifyGameWinScoreNoticeMsg {
  return {
    type: 0,
    userName: "",
    gameName: "",
    winScore: 0,
    logo: 0,
    timestamp: 0,
    multiple: 0,
    roomId: 0,
    gameId: 0,
    viplv: 0,
  };
}

export const notifyGameWinScoreNoticeMsg: MessageFns<notifyGameWinScoreNoticeMsg> = {
  encode(message: notifyGameWinScoreNoticeMsg, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.type !== 0) {
      writer.uint32(8).int32(message.type);
    }
    if (message.userName !== "") {
      writer.uint32(18).string(message.userName);
    }
    if (message.gameName !== "") {
      writer.uint32(26).string(message.gameName);
    }
    if (message.winScore !== 0) {
      writer.uint32(32).int64(message.winScore);
    }
    if (message.logo !== 0) {
      writer.uint32(40).int32(message.logo);
    }
    if (message.timestamp !== 0) {
      writer.uint32(48).int64(message.timestamp);
    }
    if (message.multiple !== 0) {
      writer.uint32(56).int32(message.multiple);
    }
    if (message.roomId !== 0) {
      writer.uint32(64).int32(message.roomId);
    }
    if (message.gameId !== 0) {
      writer.uint32(72).int32(message.gameId);
    }
    if (message.viplv !== 0) {
      writer.uint32(80).int32(message.viplv);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): notifyGameWinScoreNoticeMsg {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasenotifyGameWinScoreNoticeMsg();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.type = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.userName = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.gameName = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.winScore = longToNumber(reader.int64());
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.logo = reader.int32();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.timestamp = longToNumber(reader.int64());
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.multiple = reader.int32();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.roomId = reader.int32();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.gameId = reader.int32();
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.viplv = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): notifyGameWinScoreNoticeMsg {
    return {
      type: isSet(object.type) ? globalThis.Number(object.type) : 0,
      userName: isSet(object.userName) ? globalThis.String(object.userName) : "",
      gameName: isSet(object.gameName) ? globalThis.String(object.gameName) : "",
      winScore: isSet(object.winScore) ? globalThis.Number(object.winScore) : 0,
      logo: isSet(object.logo) ? globalThis.Number(object.logo) : 0,
      timestamp: isSet(object.timestamp) ? globalThis.Number(object.timestamp) : 0,
      multiple: isSet(object.multiple) ? globalThis.Number(object.multiple) : 0,
      roomId: isSet(object.roomId) ? globalThis.Number(object.roomId) : 0,
      gameId: isSet(object.gameId) ? globalThis.Number(object.gameId) : 0,
      viplv: isSet(object.viplv) ? globalThis.Number(object.viplv) : 0,
    };
  },

  toJSON(message: notifyGameWinScoreNoticeMsg): unknown {
    const obj: any = {};
    if (message.type !== 0) {
      obj.type = Math.round(message.type);
    }
    if (message.userName !== "") {
      obj.userName = message.userName;
    }
    if (message.gameName !== "") {
      obj.gameName = message.gameName;
    }
    if (message.winScore !== 0) {
      obj.winScore = Math.round(message.winScore);
    }
    if (message.logo !== 0) {
      obj.logo = Math.round(message.logo);
    }
    if (message.timestamp !== 0) {
      obj.timestamp = Math.round(message.timestamp);
    }
    if (message.multiple !== 0) {
      obj.multiple = Math.round(message.multiple);
    }
    if (message.roomId !== 0) {
      obj.roomId = Math.round(message.roomId);
    }
    if (message.gameId !== 0) {
      obj.gameId = Math.round(message.gameId);
    }
    if (message.viplv !== 0) {
      obj.viplv = Math.round(message.viplv);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<notifyGameWinScoreNoticeMsg>, I>>(base?: I): notifyGameWinScoreNoticeMsg {
    return notifyGameWinScoreNoticeMsg.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<notifyGameWinScoreNoticeMsg>, I>>(object: I): notifyGameWinScoreNoticeMsg {
    const message = createBasenotifyGameWinScoreNoticeMsg();
    message.type = object.type ?? 0;
    message.userName = object.userName ?? "";
    message.gameName = object.gameName ?? "";
    message.winScore = object.winScore ?? 0;
    message.logo = object.logo ?? 0;
    message.timestamp = object.timestamp ?? 0;
    message.multiple = object.multiple ?? 0;
    message.roomId = object.roomId ?? 0;
    message.gameId = object.gameId ?? 0;
    message.viplv = object.viplv ?? 0;
    return message;
  },
};

function createBasenotifyGameGradeInfo(): notifyGameGradeInfo {
  return { scoreList: [] };
}

export const notifyGameGradeInfo: MessageFns<notifyGameGradeInfo> = {
  encode(message: notifyGameGradeInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    writer.uint32(10).fork();
    for (const v of message.scoreList) {
      writer.int32(v);
    }
    writer.join();
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): notifyGameGradeInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasenotifyGameGradeInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag === 8) {
            message.scoreList.push(reader.int32());

            continue;
          }

          if (tag === 10) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.scoreList.push(reader.int32());
            }

            continue;
          }

          break;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): notifyGameGradeInfo {
    return {
      scoreList: globalThis.Array.isArray(object?.scoreList)
        ? object.scoreList.map((e: any) => globalThis.Number(e))
        : [],
    };
  },

  toJSON(message: notifyGameGradeInfo): unknown {
    const obj: any = {};
    if (message.scoreList?.length) {
      obj.scoreList = message.scoreList.map((e) => Math.round(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<notifyGameGradeInfo>, I>>(base?: I): notifyGameGradeInfo {
    return notifyGameGradeInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<notifyGameGradeInfo>, I>>(object: I): notifyGameGradeInfo {
    const message = createBasenotifyGameGradeInfo();
    message.scoreList = object.scoreList?.map((e) => e) || [];
    return message;
  },
};

function createBasenotifyUserinfoUpdate(): notifyUserinfoUpdate {
  return {
    money: 0,
    bank: 0,
    vipLevel: 0,
    vipExp: 0,
    name: "",
    logoId: 0,
    type: 0,
    changed: 0,
    phoneNo: "",
    areaCode: "",
  };
}

export const notifyUserinfoUpdate: MessageFns<notifyUserinfoUpdate> = {
  encode(message: notifyUserinfoUpdate, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.money !== 0) {
      writer.uint32(8).int64(message.money);
    }
    if (message.bank !== 0) {
      writer.uint32(16).int64(message.bank);
    }
    if (message.vipLevel !== 0) {
      writer.uint32(24).int32(message.vipLevel);
    }
    if (message.vipExp !== 0) {
      writer.uint32(32).int64(message.vipExp);
    }
    if (message.name !== "") {
      writer.uint32(42).string(message.name);
    }
    if (message.logoId !== 0) {
      writer.uint32(48).int32(message.logoId);
    }
    if (message.type !== 0) {
      writer.uint32(56).int32(message.type);
    }
    if (message.changed !== 0) {
      writer.uint32(64).int64(message.changed);
    }
    if (message.phoneNo !== "") {
      writer.uint32(74).string(message.phoneNo);
    }
    if (message.areaCode !== "") {
      writer.uint32(82).string(message.areaCode);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): notifyUserinfoUpdate {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasenotifyUserinfoUpdate();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.money = longToNumber(reader.int64());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.bank = longToNumber(reader.int64());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.vipLevel = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.vipExp = longToNumber(reader.int64());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.logoId = reader.int32();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.type = reader.int32();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.changed = longToNumber(reader.int64());
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.phoneNo = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.areaCode = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): notifyUserinfoUpdate {
    return {
      money: isSet(object.money) ? globalThis.Number(object.money) : 0,
      bank: isSet(object.bank) ? globalThis.Number(object.bank) : 0,
      vipLevel: isSet(object.vipLevel) ? globalThis.Number(object.vipLevel) : 0,
      vipExp: isSet(object.vipExp) ? globalThis.Number(object.vipExp) : 0,
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      logoId: isSet(object.logoId) ? globalThis.Number(object.logoId) : 0,
      type: isSet(object.type) ? globalThis.Number(object.type) : 0,
      changed: isSet(object.changed) ? globalThis.Number(object.changed) : 0,
      phoneNo: isSet(object.phoneNo) ? globalThis.String(object.phoneNo) : "",
      areaCode: isSet(object.areaCode) ? globalThis.String(object.areaCode) : "",
    };
  },

  toJSON(message: notifyUserinfoUpdate): unknown {
    const obj: any = {};
    if (message.money !== 0) {
      obj.money = Math.round(message.money);
    }
    if (message.bank !== 0) {
      obj.bank = Math.round(message.bank);
    }
    if (message.vipLevel !== 0) {
      obj.vipLevel = Math.round(message.vipLevel);
    }
    if (message.vipExp !== 0) {
      obj.vipExp = Math.round(message.vipExp);
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.logoId !== 0) {
      obj.logoId = Math.round(message.logoId);
    }
    if (message.type !== 0) {
      obj.type = Math.round(message.type);
    }
    if (message.changed !== 0) {
      obj.changed = Math.round(message.changed);
    }
    if (message.phoneNo !== "") {
      obj.phoneNo = message.phoneNo;
    }
    if (message.areaCode !== "") {
      obj.areaCode = message.areaCode;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<notifyUserinfoUpdate>, I>>(base?: I): notifyUserinfoUpdate {
    return notifyUserinfoUpdate.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<notifyUserinfoUpdate>, I>>(object: I): notifyUserinfoUpdate {
    const message = createBasenotifyUserinfoUpdate();
    message.money = object.money ?? 0;
    message.bank = object.bank ?? 0;
    message.vipLevel = object.vipLevel ?? 0;
    message.vipExp = object.vipExp ?? 0;
    message.name = object.name ?? "";
    message.logoId = object.logoId ?? 0;
    message.type = object.type ?? 0;
    message.changed = object.changed ?? 0;
    message.phoneNo = object.phoneNo ?? "";
    message.areaCode = object.areaCode ?? "";
    return message;
  },
};

function createBasescJackpotWinnerList(): scJackpotWinnerList {
  return { winners: [] };
}

export const scJackpotWinnerList: MessageFns<scJackpotWinnerList> = {
  encode(message: scJackpotWinnerList, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.winners) {
      notifyGameWinScoreNoticeMsg.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): scJackpotWinnerList {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasescJackpotWinnerList();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.winners.push(notifyGameWinScoreNoticeMsg.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): scJackpotWinnerList {
    return {
      winners: globalThis.Array.isArray(object?.winners)
        ? object.winners.map((e: any) => notifyGameWinScoreNoticeMsg.fromJSON(e))
        : [],
    };
  },

  toJSON(message: scJackpotWinnerList): unknown {
    const obj: any = {};
    if (message.winners?.length) {
      obj.winners = message.winners.map((e) => notifyGameWinScoreNoticeMsg.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<scJackpotWinnerList>, I>>(base?: I): scJackpotWinnerList {
    return scJackpotWinnerList.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<scJackpotWinnerList>, I>>(object: I): scJackpotWinnerList {
    const message = createBasescJackpotWinnerList();
    message.winners = object.winners?.map((e) => notifyGameWinScoreNoticeMsg.fromPartial(e)) || [];
    return message;
  },
};

function createBasescBetForbidMsg(): scBetForbidMsg {
  return { forbid: 0 };
}

export const scBetForbidMsg: MessageFns<scBetForbidMsg> = {
  encode(message: scBetForbidMsg, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.forbid !== 0) {
      writer.uint32(8).int32(message.forbid);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): scBetForbidMsg {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasescBetForbidMsg();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.forbid = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): scBetForbidMsg {
    return { forbid: isSet(object.forbid) ? globalThis.Number(object.forbid) : 0 };
  },

  toJSON(message: scBetForbidMsg): unknown {
    const obj: any = {};
    if (message.forbid !== 0) {
      obj.forbid = Math.round(message.forbid);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<scBetForbidMsg>, I>>(base?: I): scBetForbidMsg {
    return scBetForbidMsg.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<scBetForbidMsg>, I>>(object: I): scBetForbidMsg {
    const message = createBasescBetForbidMsg();
    message.forbid = object.forbid ?? 0;
    return message;
  },
};

function createBasenotifyKickWarnMsg(): notifyKickWarnMsg {
  return { param: 0 };
}

export const notifyKickWarnMsg: MessageFns<notifyKickWarnMsg> = {
  encode(message: notifyKickWarnMsg, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.param !== 0) {
      writer.uint32(8).int32(message.param);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): notifyKickWarnMsg {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasenotifyKickWarnMsg();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.param = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): notifyKickWarnMsg {
    return { param: isSet(object.param) ? globalThis.Number(object.param) : 0 };
  },

  toJSON(message: notifyKickWarnMsg): unknown {
    const obj: any = {};
    if (message.param !== 0) {
      obj.param = Math.round(message.param);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<notifyKickWarnMsg>, I>>(base?: I): notifyKickWarnMsg {
    return notifyKickWarnMsg.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<notifyKickWarnMsg>, I>>(object: I): notifyKickWarnMsg {
    const message = createBasenotifyKickWarnMsg();
    message.param = object.param ?? 0;
    return message;
  },
};

function createBasenotifyUserRechargeResultInfo(): notifyUserRechargeResultInfo {
  return { firstRecharge: 0, rechargeCoins: 0, rechargeCash: 0 };
}

export const notifyUserRechargeResultInfo: MessageFns<notifyUserRechargeResultInfo> = {
  encode(message: notifyUserRechargeResultInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.firstRecharge !== 0) {
      writer.uint32(8).int32(message.firstRecharge);
    }
    if (message.rechargeCoins !== 0) {
      writer.uint32(16).int64(message.rechargeCoins);
    }
    if (message.rechargeCash !== 0) {
      writer.uint32(24).int64(message.rechargeCash);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): notifyUserRechargeResultInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasenotifyUserRechargeResultInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.firstRecharge = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.rechargeCoins = longToNumber(reader.int64());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.rechargeCash = longToNumber(reader.int64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): notifyUserRechargeResultInfo {
    return {
      firstRecharge: isSet(object.firstRecharge) ? globalThis.Number(object.firstRecharge) : 0,
      rechargeCoins: isSet(object.rechargeCoins) ? globalThis.Number(object.rechargeCoins) : 0,
      rechargeCash: isSet(object.rechargeCash) ? globalThis.Number(object.rechargeCash) : 0,
    };
  },

  toJSON(message: notifyUserRechargeResultInfo): unknown {
    const obj: any = {};
    if (message.firstRecharge !== 0) {
      obj.firstRecharge = Math.round(message.firstRecharge);
    }
    if (message.rechargeCoins !== 0) {
      obj.rechargeCoins = Math.round(message.rechargeCoins);
    }
    if (message.rechargeCash !== 0) {
      obj.rechargeCash = Math.round(message.rechargeCash);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<notifyUserRechargeResultInfo>, I>>(base?: I): notifyUserRechargeResultInfo {
    return notifyUserRechargeResultInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<notifyUserRechargeResultInfo>, I>>(object: I): notifyUserRechargeResultInfo {
    const message = createBasenotifyUserRechargeResultInfo();
    message.firstRecharge = object.firstRecharge ?? 0;
    message.rechargeCoins = object.rechargeCoins ?? 0;
    message.rechargeCash = object.rechargeCash ?? 0;
    return message;
  },
};

function createBasescNoticeMarquee(): scNoticeMarquee {
  return { noticelist: [] };
}

export const scNoticeMarquee: MessageFns<scNoticeMarquee> = {
  encode(message: scNoticeMarquee, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.noticelist) {
      notifyGameWinScoreNoticeMsg.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): scNoticeMarquee {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasescNoticeMarquee();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.noticelist.push(notifyGameWinScoreNoticeMsg.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): scNoticeMarquee {
    return {
      noticelist: globalThis.Array.isArray(object?.noticelist)
        ? object.noticelist.map((e: any) => notifyGameWinScoreNoticeMsg.fromJSON(e))
        : [],
    };
  },

  toJSON(message: scNoticeMarquee): unknown {
    const obj: any = {};
    if (message.noticelist?.length) {
      obj.noticelist = message.noticelist.map((e) => notifyGameWinScoreNoticeMsg.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<scNoticeMarquee>, I>>(base?: I): scNoticeMarquee {
    return scNoticeMarquee.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<scNoticeMarquee>, I>>(object: I): scNoticeMarquee {
    const message = createBasescNoticeMarquee();
    message.noticelist = object.noticelist?.map((e) => notifyGameWinScoreNoticeMsg.fromPartial(e)) || [];
    return message;
  },
};

function createBasescOtherUserSit(): scOtherUserSit {
  return { userID: 0, deskNo: 0, deskStation: 0, nickName: "", logoID: 0 };
}

export const scOtherUserSit: MessageFns<scOtherUserSit> = {
  encode(message: scOtherUserSit, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userID !== 0) {
      writer.uint32(8).int32(message.userID);
    }
    if (message.deskNo !== 0) {
      writer.uint32(16).int32(message.deskNo);
    }
    if (message.deskStation !== 0) {
      writer.uint32(24).int32(message.deskStation);
    }
    if (message.nickName !== "") {
      writer.uint32(34).string(message.nickName);
    }
    if (message.logoID !== 0) {
      writer.uint32(40).int32(message.logoID);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): scOtherUserSit {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasescOtherUserSit();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.userID = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.deskNo = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.deskStation = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.nickName = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.logoID = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): scOtherUserSit {
    return {
      userID: isSet(object.userID) ? globalThis.Number(object.userID) : 0,
      deskNo: isSet(object.deskNo) ? globalThis.Number(object.deskNo) : 0,
      deskStation: isSet(object.deskStation) ? globalThis.Number(object.deskStation) : 0,
      nickName: isSet(object.nickName) ? globalThis.String(object.nickName) : "",
      logoID: isSet(object.logoID) ? globalThis.Number(object.logoID) : 0,
    };
  },

  toJSON(message: scOtherUserSit): unknown {
    const obj: any = {};
    if (message.userID !== 0) {
      obj.userID = Math.round(message.userID);
    }
    if (message.deskNo !== 0) {
      obj.deskNo = Math.round(message.deskNo);
    }
    if (message.deskStation !== 0) {
      obj.deskStation = Math.round(message.deskStation);
    }
    if (message.nickName !== "") {
      obj.nickName = message.nickName;
    }
    if (message.logoID !== 0) {
      obj.logoID = Math.round(message.logoID);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<scOtherUserSit>, I>>(base?: I): scOtherUserSit {
    return scOtherUserSit.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<scOtherUserSit>, I>>(object: I): scOtherUserSit {
    const message = createBasescOtherUserSit();
    message.userID = object.userID ?? 0;
    message.deskNo = object.deskNo ?? 0;
    message.deskStation = object.deskStation ?? 0;
    message.nickName = object.nickName ?? "";
    message.logoID = object.logoID ?? 0;
    return message;
  },
};

function createBasescOtherUserCut(): scOtherUserCut {
  return { userID: 0, deskNo: 0 };
}

export const scOtherUserCut: MessageFns<scOtherUserCut> = {
  encode(message: scOtherUserCut, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userID !== 0) {
      writer.uint32(8).int32(message.userID);
    }
    if (message.deskNo !== 0) {
      writer.uint32(16).int32(message.deskNo);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): scOtherUserCut {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasescOtherUserCut();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.userID = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.deskNo = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): scOtherUserCut {
    return {
      userID: isSet(object.userID) ? globalThis.Number(object.userID) : 0,
      deskNo: isSet(object.deskNo) ? globalThis.Number(object.deskNo) : 0,
    };
  },

  toJSON(message: scOtherUserCut): unknown {
    const obj: any = {};
    if (message.userID !== 0) {
      obj.userID = Math.round(message.userID);
    }
    if (message.deskNo !== 0) {
      obj.deskNo = Math.round(message.deskNo);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<scOtherUserCut>, I>>(base?: I): scOtherUserCut {
    return scOtherUserCut.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<scOtherUserCut>, I>>(object: I): scOtherUserCut {
    const message = createBasescOtherUserCut();
    message.userID = object.userID ?? 0;
    message.deskNo = object.deskNo ?? 0;
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function longToNumber(int64: { toString(): string }): number {
  const num = globalThis.Number(int64.toString());
  if (num > globalThis.Number.MAX_SAFE_INTEGER) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (num < globalThis.Number.MIN_SAFE_INTEGER) {
    throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return num;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
