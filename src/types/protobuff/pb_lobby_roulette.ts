// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.8.3
//   protoc               v6.33.0
// source: pb_lobby_roulette.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";

export const protobufPackage = "pb_lobby_roulette";

export interface rouletteItem {
  icon: number;
  itemscore: number;
}

export interface roulette {
  basepoint: number;
  type: number;
  item: rouletteItem[];
}

export interface rouletteBase {
  bonuspoint: number;
  list: roulette[];
}

export interface csRouletteSpin {
  type: number;
}

export interface scRouletteSpin {
  type: number;
  index: number;
  reward: number;
  bonuspoint: number;
  score: number;
}

export interface csRouletteRecord {
  type: number;
}

export interface spinRecord {
  nickname: string;
  reward: number;
  type: number;
  timestamp: number;
}

export interface scRouletteRecord {
  type: number;
  list: spinRecord[];
}

export interface scBenefitsBase {
  dayCount: number;
  todayTotal: number;
  todayGet: number;
  bonuspoint: number;
  status: number;
  todayScore: number;
}

export interface scGetBenefits {
  result: number;
}

function createBaserouletteItem(): rouletteItem {
  return { icon: 0, itemscore: 0 };
}

export const rouletteItem: MessageFns<rouletteItem> = {
  encode(message: rouletteItem, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.icon !== 0) {
      writer.uint32(8).int32(message.icon);
    }
    if (message.itemscore !== 0) {
      writer.uint32(16).int64(message.itemscore);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): rouletteItem {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaserouletteItem();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.icon = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.itemscore = longToNumber(reader.int64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): rouletteItem {
    return {
      icon: isSet(object.icon) ? globalThis.Number(object.icon) : 0,
      itemscore: isSet(object.itemscore) ? globalThis.Number(object.itemscore) : 0,
    };
  },

  toJSON(message: rouletteItem): unknown {
    const obj: any = {};
    if (message.icon !== 0) {
      obj.icon = Math.round(message.icon);
    }
    if (message.itemscore !== 0) {
      obj.itemscore = Math.round(message.itemscore);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<rouletteItem>, I>>(base?: I): rouletteItem {
    return rouletteItem.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<rouletteItem>, I>>(object: I): rouletteItem {
    const message = createBaserouletteItem();
    message.icon = object.icon ?? 0;
    message.itemscore = object.itemscore ?? 0;
    return message;
  },
};

function createBaseroulette(): roulette {
  return { basepoint: 0, type: 0, item: [] };
}

export const roulette: MessageFns<roulette> = {
  encode(message: roulette, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.basepoint !== 0) {
      writer.uint32(8).int64(message.basepoint);
    }
    if (message.type !== 0) {
      writer.uint32(16).int32(message.type);
    }
    for (const v of message.item) {
      rouletteItem.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): roulette {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseroulette();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.basepoint = longToNumber(reader.int64());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.type = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.item.push(rouletteItem.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): roulette {
    return {
      basepoint: isSet(object.basepoint) ? globalThis.Number(object.basepoint) : 0,
      type: isSet(object.type) ? globalThis.Number(object.type) : 0,
      item: globalThis.Array.isArray(object?.item) ? object.item.map((e: any) => rouletteItem.fromJSON(e)) : [],
    };
  },

  toJSON(message: roulette): unknown {
    const obj: any = {};
    if (message.basepoint !== 0) {
      obj.basepoint = Math.round(message.basepoint);
    }
    if (message.type !== 0) {
      obj.type = Math.round(message.type);
    }
    if (message.item?.length) {
      obj.item = message.item.map((e) => rouletteItem.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<roulette>, I>>(base?: I): roulette {
    return roulette.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<roulette>, I>>(object: I): roulette {
    const message = createBaseroulette();
    message.basepoint = object.basepoint ?? 0;
    message.type = object.type ?? 0;
    message.item = object.item?.map((e) => rouletteItem.fromPartial(e)) || [];
    return message;
  },
};

function createBaserouletteBase(): rouletteBase {
  return { bonuspoint: 0, list: [] };
}

export const rouletteBase: MessageFns<rouletteBase> = {
  encode(message: rouletteBase, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.bonuspoint !== 0) {
      writer.uint32(8).int64(message.bonuspoint);
    }
    for (const v of message.list) {
      roulette.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): rouletteBase {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaserouletteBase();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.bonuspoint = longToNumber(reader.int64());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.list.push(roulette.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): rouletteBase {
    return {
      bonuspoint: isSet(object.bonuspoint) ? globalThis.Number(object.bonuspoint) : 0,
      list: globalThis.Array.isArray(object?.list) ? object.list.map((e: any) => roulette.fromJSON(e)) : [],
    };
  },

  toJSON(message: rouletteBase): unknown {
    const obj: any = {};
    if (message.bonuspoint !== 0) {
      obj.bonuspoint = Math.round(message.bonuspoint);
    }
    if (message.list?.length) {
      obj.list = message.list.map((e) => roulette.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<rouletteBase>, I>>(base?: I): rouletteBase {
    return rouletteBase.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<rouletteBase>, I>>(object: I): rouletteBase {
    const message = createBaserouletteBase();
    message.bonuspoint = object.bonuspoint ?? 0;
    message.list = object.list?.map((e) => roulette.fromPartial(e)) || [];
    return message;
  },
};

function createBasecsRouletteSpin(): csRouletteSpin {
  return { type: 0 };
}

export const csRouletteSpin: MessageFns<csRouletteSpin> = {
  encode(message: csRouletteSpin, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.type !== 0) {
      writer.uint32(8).int32(message.type);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): csRouletteSpin {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasecsRouletteSpin();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.type = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): csRouletteSpin {
    return { type: isSet(object.type) ? globalThis.Number(object.type) : 0 };
  },

  toJSON(message: csRouletteSpin): unknown {
    const obj: any = {};
    if (message.type !== 0) {
      obj.type = Math.round(message.type);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<csRouletteSpin>, I>>(base?: I): csRouletteSpin {
    return csRouletteSpin.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<csRouletteSpin>, I>>(object: I): csRouletteSpin {
    const message = createBasecsRouletteSpin();
    message.type = object.type ?? 0;
    return message;
  },
};

function createBasescRouletteSpin(): scRouletteSpin {
  return { type: 0, index: 0, reward: 0, bonuspoint: 0, score: 0 };
}

export const scRouletteSpin: MessageFns<scRouletteSpin> = {
  encode(message: scRouletteSpin, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.type !== 0) {
      writer.uint32(8).int32(message.type);
    }
    if (message.index !== 0) {
      writer.uint32(16).int32(message.index);
    }
    if (message.reward !== 0) {
      writer.uint32(24).int64(message.reward);
    }
    if (message.bonuspoint !== 0) {
      writer.uint32(32).int64(message.bonuspoint);
    }
    if (message.score !== 0) {
      writer.uint32(40).int64(message.score);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): scRouletteSpin {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasescRouletteSpin();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.type = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.index = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.reward = longToNumber(reader.int64());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.bonuspoint = longToNumber(reader.int64());
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.score = longToNumber(reader.int64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): scRouletteSpin {
    return {
      type: isSet(object.type) ? globalThis.Number(object.type) : 0,
      index: isSet(object.index) ? globalThis.Number(object.index) : 0,
      reward: isSet(object.reward) ? globalThis.Number(object.reward) : 0,
      bonuspoint: isSet(object.bonuspoint) ? globalThis.Number(object.bonuspoint) : 0,
      score: isSet(object.score) ? globalThis.Number(object.score) : 0,
    };
  },

  toJSON(message: scRouletteSpin): unknown {
    const obj: any = {};
    if (message.type !== 0) {
      obj.type = Math.round(message.type);
    }
    if (message.index !== 0) {
      obj.index = Math.round(message.index);
    }
    if (message.reward !== 0) {
      obj.reward = Math.round(message.reward);
    }
    if (message.bonuspoint !== 0) {
      obj.bonuspoint = Math.round(message.bonuspoint);
    }
    if (message.score !== 0) {
      obj.score = Math.round(message.score);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<scRouletteSpin>, I>>(base?: I): scRouletteSpin {
    return scRouletteSpin.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<scRouletteSpin>, I>>(object: I): scRouletteSpin {
    const message = createBasescRouletteSpin();
    message.type = object.type ?? 0;
    message.index = object.index ?? 0;
    message.reward = object.reward ?? 0;
    message.bonuspoint = object.bonuspoint ?? 0;
    message.score = object.score ?? 0;
    return message;
  },
};

function createBasecsRouletteRecord(): csRouletteRecord {
  return { type: 0 };
}

export const csRouletteRecord: MessageFns<csRouletteRecord> = {
  encode(message: csRouletteRecord, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.type !== 0) {
      writer.uint32(8).int32(message.type);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): csRouletteRecord {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasecsRouletteRecord();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.type = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): csRouletteRecord {
    return { type: isSet(object.type) ? globalThis.Number(object.type) : 0 };
  },

  toJSON(message: csRouletteRecord): unknown {
    const obj: any = {};
    if (message.type !== 0) {
      obj.type = Math.round(message.type);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<csRouletteRecord>, I>>(base?: I): csRouletteRecord {
    return csRouletteRecord.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<csRouletteRecord>, I>>(object: I): csRouletteRecord {
    const message = createBasecsRouletteRecord();
    message.type = object.type ?? 0;
    return message;
  },
};

function createBasespinRecord(): spinRecord {
  return { nickname: "", reward: 0, type: 0, timestamp: 0 };
}

export const spinRecord: MessageFns<spinRecord> = {
  encode(message: spinRecord, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.nickname !== "") {
      writer.uint32(10).string(message.nickname);
    }
    if (message.reward !== 0) {
      writer.uint32(16).int64(message.reward);
    }
    if (message.type !== 0) {
      writer.uint32(24).int32(message.type);
    }
    if (message.timestamp !== 0) {
      writer.uint32(32).int64(message.timestamp);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): spinRecord {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasespinRecord();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.nickname = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.reward = longToNumber(reader.int64());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.type = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.timestamp = longToNumber(reader.int64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): spinRecord {
    return {
      nickname: isSet(object.nickname) ? globalThis.String(object.nickname) : "",
      reward: isSet(object.reward) ? globalThis.Number(object.reward) : 0,
      type: isSet(object.type) ? globalThis.Number(object.type) : 0,
      timestamp: isSet(object.timestamp) ? globalThis.Number(object.timestamp) : 0,
    };
  },

  toJSON(message: spinRecord): unknown {
    const obj: any = {};
    if (message.nickname !== "") {
      obj.nickname = message.nickname;
    }
    if (message.reward !== 0) {
      obj.reward = Math.round(message.reward);
    }
    if (message.type !== 0) {
      obj.type = Math.round(message.type);
    }
    if (message.timestamp !== 0) {
      obj.timestamp = Math.round(message.timestamp);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<spinRecord>, I>>(base?: I): spinRecord {
    return spinRecord.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<spinRecord>, I>>(object: I): spinRecord {
    const message = createBasespinRecord();
    message.nickname = object.nickname ?? "";
    message.reward = object.reward ?? 0;
    message.type = object.type ?? 0;
    message.timestamp = object.timestamp ?? 0;
    return message;
  },
};

function createBasescRouletteRecord(): scRouletteRecord {
  return { type: 0, list: [] };
}

export const scRouletteRecord: MessageFns<scRouletteRecord> = {
  encode(message: scRouletteRecord, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.type !== 0) {
      writer.uint32(8).int32(message.type);
    }
    for (const v of message.list) {
      spinRecord.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): scRouletteRecord {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasescRouletteRecord();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.type = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.list.push(spinRecord.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): scRouletteRecord {
    return {
      type: isSet(object.type) ? globalThis.Number(object.type) : 0,
      list: globalThis.Array.isArray(object?.list) ? object.list.map((e: any) => spinRecord.fromJSON(e)) : [],
    };
  },

  toJSON(message: scRouletteRecord): unknown {
    const obj: any = {};
    if (message.type !== 0) {
      obj.type = Math.round(message.type);
    }
    if (message.list?.length) {
      obj.list = message.list.map((e) => spinRecord.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<scRouletteRecord>, I>>(base?: I): scRouletteRecord {
    return scRouletteRecord.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<scRouletteRecord>, I>>(object: I): scRouletteRecord {
    const message = createBasescRouletteRecord();
    message.type = object.type ?? 0;
    message.list = object.list?.map((e) => spinRecord.fromPartial(e)) || [];
    return message;
  },
};

function createBasescBenefitsBase(): scBenefitsBase {
  return { dayCount: 0, todayTotal: 0, todayGet: 0, bonuspoint: 0, status: 0, todayScore: 0 };
}

export const scBenefitsBase: MessageFns<scBenefitsBase> = {
  encode(message: scBenefitsBase, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.dayCount !== 0) {
      writer.uint32(8).int32(message.dayCount);
    }
    if (message.todayTotal !== 0) {
      writer.uint32(16).int64(message.todayTotal);
    }
    if (message.todayGet !== 0) {
      writer.uint32(24).int64(message.todayGet);
    }
    if (message.bonuspoint !== 0) {
      writer.uint32(32).int64(message.bonuspoint);
    }
    if (message.status !== 0) {
      writer.uint32(40).int32(message.status);
    }
    if (message.todayScore !== 0) {
      writer.uint32(48).int64(message.todayScore);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): scBenefitsBase {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasescBenefitsBase();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.dayCount = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.todayTotal = longToNumber(reader.int64());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.todayGet = longToNumber(reader.int64());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.bonuspoint = longToNumber(reader.int64());
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.status = reader.int32();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.todayScore = longToNumber(reader.int64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): scBenefitsBase {
    return {
      dayCount: isSet(object.dayCount) ? globalThis.Number(object.dayCount) : 0,
      todayTotal: isSet(object.todayTotal) ? globalThis.Number(object.todayTotal) : 0,
      todayGet: isSet(object.todayGet) ? globalThis.Number(object.todayGet) : 0,
      bonuspoint: isSet(object.bonuspoint) ? globalThis.Number(object.bonuspoint) : 0,
      status: isSet(object.status) ? globalThis.Number(object.status) : 0,
      todayScore: isSet(object.todayScore) ? globalThis.Number(object.todayScore) : 0,
    };
  },

  toJSON(message: scBenefitsBase): unknown {
    const obj: any = {};
    if (message.dayCount !== 0) {
      obj.dayCount = Math.round(message.dayCount);
    }
    if (message.todayTotal !== 0) {
      obj.todayTotal = Math.round(message.todayTotal);
    }
    if (message.todayGet !== 0) {
      obj.todayGet = Math.round(message.todayGet);
    }
    if (message.bonuspoint !== 0) {
      obj.bonuspoint = Math.round(message.bonuspoint);
    }
    if (message.status !== 0) {
      obj.status = Math.round(message.status);
    }
    if (message.todayScore !== 0) {
      obj.todayScore = Math.round(message.todayScore);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<scBenefitsBase>, I>>(base?: I): scBenefitsBase {
    return scBenefitsBase.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<scBenefitsBase>, I>>(object: I): scBenefitsBase {
    const message = createBasescBenefitsBase();
    message.dayCount = object.dayCount ?? 0;
    message.todayTotal = object.todayTotal ?? 0;
    message.todayGet = object.todayGet ?? 0;
    message.bonuspoint = object.bonuspoint ?? 0;
    message.status = object.status ?? 0;
    message.todayScore = object.todayScore ?? 0;
    return message;
  },
};

function createBasescGetBenefits(): scGetBenefits {
  return { result: 0 };
}

export const scGetBenefits: MessageFns<scGetBenefits> = {
  encode(message: scGetBenefits, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.result !== 0) {
      writer.uint32(8).int32(message.result);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): scGetBenefits {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasescGetBenefits();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.result = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): scGetBenefits {
    return { result: isSet(object.result) ? globalThis.Number(object.result) : 0 };
  },

  toJSON(message: scGetBenefits): unknown {
    const obj: any = {};
    if (message.result !== 0) {
      obj.result = Math.round(message.result);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<scGetBenefits>, I>>(base?: I): scGetBenefits {
    return scGetBenefits.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<scGetBenefits>, I>>(object: I): scGetBenefits {
    const message = createBasescGetBenefits();
    message.result = object.result ?? 0;
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function longToNumber(int64: { toString(): string }): number {
  const num = globalThis.Number(int64.toString());
  if (num > globalThis.Number.MAX_SAFE_INTEGER) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (num < globalThis.Number.MIN_SAFE_INTEGER) {
    throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return num;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
