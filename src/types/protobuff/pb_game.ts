// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.8.3
//   protoc               v6.33.0
// source: pb_game.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";

export const protobufPackage = "pb_game";

export interface csGameroomList {
  gameId: number;
}

export interface scGameroomList {
  rooms: gameroomInfo[];
}

export interface gameroomInfo {
  roomId: number;
  roomName: string;
  roomType: number;
  playerCount: number;
  roomStatus: number;
  minEnter: number;
  maxEnter: number;
}

export interface csAskenterroom {
  gameId: number;
  roomId: number;
}

export interface scAskenterroom {
  serverIp: string;
  socketPort: number;
  gameNameId: number;
  gameName: string;
  gameRoomId: number;
  limitbet: number;
}

export interface scGameList {
  games: gameInfo[];
}

export interface gameInfo {
  gameId: number;
  gameName: string;
  sort: number;
  kindId: number;
  isRoom: number;
  tag: number;
  viplv: number;
  gameType: number;
}

export interface notifyGameJackport {
  gameId: number;
  jackpot: number;
}

export interface notifyNeedEnterGame {
  gameId: number;
  roomId: number;
}

function createBasecsGameroomList(): csGameroomList {
  return { gameId: 0 };
}

export const csGameroomList: MessageFns<csGameroomList> = {
  encode(message: csGameroomList, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.gameId !== 0) {
      writer.uint32(8).int32(message.gameId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): csGameroomList {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasecsGameroomList();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.gameId = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): csGameroomList {
    return { gameId: isSet(object.gameId) ? globalThis.Number(object.gameId) : 0 };
  },

  toJSON(message: csGameroomList): unknown {
    const obj: any = {};
    if (message.gameId !== 0) {
      obj.gameId = Math.round(message.gameId);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<csGameroomList>, I>>(base?: I): csGameroomList {
    return csGameroomList.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<csGameroomList>, I>>(object: I): csGameroomList {
    const message = createBasecsGameroomList();
    message.gameId = object.gameId ?? 0;
    return message;
  },
};

function createBasescGameroomList(): scGameroomList {
  return { rooms: [] };
}

export const scGameroomList: MessageFns<scGameroomList> = {
  encode(message: scGameroomList, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.rooms) {
      gameroomInfo.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): scGameroomList {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasescGameroomList();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.rooms.push(gameroomInfo.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): scGameroomList {
    return {
      rooms: globalThis.Array.isArray(object?.rooms) ? object.rooms.map((e: any) => gameroomInfo.fromJSON(e)) : [],
    };
  },

  toJSON(message: scGameroomList): unknown {
    const obj: any = {};
    if (message.rooms?.length) {
      obj.rooms = message.rooms.map((e) => gameroomInfo.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<scGameroomList>, I>>(base?: I): scGameroomList {
    return scGameroomList.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<scGameroomList>, I>>(object: I): scGameroomList {
    const message = createBasescGameroomList();
    message.rooms = object.rooms?.map((e) => gameroomInfo.fromPartial(e)) || [];
    return message;
  },
};

function createBasegameroomInfo(): gameroomInfo {
  return { roomId: 0, roomName: "", roomType: 0, playerCount: 0, roomStatus: 0, minEnter: 0, maxEnter: 0 };
}

export const gameroomInfo: MessageFns<gameroomInfo> = {
  encode(message: gameroomInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.roomId !== 0) {
      writer.uint32(8).int32(message.roomId);
    }
    if (message.roomName !== "") {
      writer.uint32(18).string(message.roomName);
    }
    if (message.roomType !== 0) {
      writer.uint32(24).int32(message.roomType);
    }
    if (message.playerCount !== 0) {
      writer.uint32(32).int32(message.playerCount);
    }
    if (message.roomStatus !== 0) {
      writer.uint32(40).int32(message.roomStatus);
    }
    if (message.minEnter !== 0) {
      writer.uint32(48).int32(message.minEnter);
    }
    if (message.maxEnter !== 0) {
      writer.uint32(56).int32(message.maxEnter);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): gameroomInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasegameroomInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.roomId = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.roomName = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.roomType = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.playerCount = reader.int32();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.roomStatus = reader.int32();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.minEnter = reader.int32();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.maxEnter = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): gameroomInfo {
    return {
      roomId: isSet(object.roomId) ? globalThis.Number(object.roomId) : 0,
      roomName: isSet(object.roomName) ? globalThis.String(object.roomName) : "",
      roomType: isSet(object.roomType) ? globalThis.Number(object.roomType) : 0,
      playerCount: isSet(object.playerCount) ? globalThis.Number(object.playerCount) : 0,
      roomStatus: isSet(object.roomStatus) ? globalThis.Number(object.roomStatus) : 0,
      minEnter: isSet(object.minEnter) ? globalThis.Number(object.minEnter) : 0,
      maxEnter: isSet(object.maxEnter) ? globalThis.Number(object.maxEnter) : 0,
    };
  },

  toJSON(message: gameroomInfo): unknown {
    const obj: any = {};
    if (message.roomId !== 0) {
      obj.roomId = Math.round(message.roomId);
    }
    if (message.roomName !== "") {
      obj.roomName = message.roomName;
    }
    if (message.roomType !== 0) {
      obj.roomType = Math.round(message.roomType);
    }
    if (message.playerCount !== 0) {
      obj.playerCount = Math.round(message.playerCount);
    }
    if (message.roomStatus !== 0) {
      obj.roomStatus = Math.round(message.roomStatus);
    }
    if (message.minEnter !== 0) {
      obj.minEnter = Math.round(message.minEnter);
    }
    if (message.maxEnter !== 0) {
      obj.maxEnter = Math.round(message.maxEnter);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<gameroomInfo>, I>>(base?: I): gameroomInfo {
    return gameroomInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<gameroomInfo>, I>>(object: I): gameroomInfo {
    const message = createBasegameroomInfo();
    message.roomId = object.roomId ?? 0;
    message.roomName = object.roomName ?? "";
    message.roomType = object.roomType ?? 0;
    message.playerCount = object.playerCount ?? 0;
    message.roomStatus = object.roomStatus ?? 0;
    message.minEnter = object.minEnter ?? 0;
    message.maxEnter = object.maxEnter ?? 0;
    return message;
  },
};

function createBasecsAskenterroom(): csAskenterroom {
  return { gameId: 0, roomId: 0 };
}

export const csAskenterroom: MessageFns<csAskenterroom> = {
  encode(message: csAskenterroom, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.gameId !== 0) {
      writer.uint32(8).int32(message.gameId);
    }
    if (message.roomId !== 0) {
      writer.uint32(16).int32(message.roomId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): csAskenterroom {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasecsAskenterroom();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.gameId = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.roomId = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): csAskenterroom {
    return {
      gameId: isSet(object.gameId) ? globalThis.Number(object.gameId) : 0,
      roomId: isSet(object.roomId) ? globalThis.Number(object.roomId) : 0,
    };
  },

  toJSON(message: csAskenterroom): unknown {
    const obj: any = {};
    if (message.gameId !== 0) {
      obj.gameId = Math.round(message.gameId);
    }
    if (message.roomId !== 0) {
      obj.roomId = Math.round(message.roomId);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<csAskenterroom>, I>>(base?: I): csAskenterroom {
    return csAskenterroom.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<csAskenterroom>, I>>(object: I): csAskenterroom {
    const message = createBasecsAskenterroom();
    message.gameId = object.gameId ?? 0;
    message.roomId = object.roomId ?? 0;
    return message;
  },
};

function createBasescAskenterroom(): scAskenterroom {
  return { serverIp: "", socketPort: 0, gameNameId: 0, gameName: "", gameRoomId: 0, limitbet: 0 };
}

export const scAskenterroom: MessageFns<scAskenterroom> = {
  encode(message: scAskenterroom, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.serverIp !== "") {
      writer.uint32(10).string(message.serverIp);
    }
    if (message.socketPort !== 0) {
      writer.uint32(16).int32(message.socketPort);
    }
    if (message.gameNameId !== 0) {
      writer.uint32(24).int32(message.gameNameId);
    }
    if (message.gameName !== "") {
      writer.uint32(34).string(message.gameName);
    }
    if (message.gameRoomId !== 0) {
      writer.uint32(40).int32(message.gameRoomId);
    }
    if (message.limitbet !== 0) {
      writer.uint32(48).int32(message.limitbet);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): scAskenterroom {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasescAskenterroom();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.serverIp = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.socketPort = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.gameNameId = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.gameName = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.gameRoomId = reader.int32();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.limitbet = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): scAskenterroom {
    return {
      serverIp: isSet(object.serverIp) ? globalThis.String(object.serverIp) : "",
      socketPort: isSet(object.socketPort) ? globalThis.Number(object.socketPort) : 0,
      gameNameId: isSet(object.gameNameId) ? globalThis.Number(object.gameNameId) : 0,
      gameName: isSet(object.gameName) ? globalThis.String(object.gameName) : "",
      gameRoomId: isSet(object.gameRoomId) ? globalThis.Number(object.gameRoomId) : 0,
      limitbet: isSet(object.limitbet) ? globalThis.Number(object.limitbet) : 0,
    };
  },

  toJSON(message: scAskenterroom): unknown {
    const obj: any = {};
    if (message.serverIp !== "") {
      obj.serverIp = message.serverIp;
    }
    if (message.socketPort !== 0) {
      obj.socketPort = Math.round(message.socketPort);
    }
    if (message.gameNameId !== 0) {
      obj.gameNameId = Math.round(message.gameNameId);
    }
    if (message.gameName !== "") {
      obj.gameName = message.gameName;
    }
    if (message.gameRoomId !== 0) {
      obj.gameRoomId = Math.round(message.gameRoomId);
    }
    if (message.limitbet !== 0) {
      obj.limitbet = Math.round(message.limitbet);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<scAskenterroom>, I>>(base?: I): scAskenterroom {
    return scAskenterroom.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<scAskenterroom>, I>>(object: I): scAskenterroom {
    const message = createBasescAskenterroom();
    message.serverIp = object.serverIp ?? "";
    message.socketPort = object.socketPort ?? 0;
    message.gameNameId = object.gameNameId ?? 0;
    message.gameName = object.gameName ?? "";
    message.gameRoomId = object.gameRoomId ?? 0;
    message.limitbet = object.limitbet ?? 0;
    return message;
  },
};

function createBasescGameList(): scGameList {
  return { games: [] };
}

export const scGameList: MessageFns<scGameList> = {
  encode(message: scGameList, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.games) {
      gameInfo.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): scGameList {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasescGameList();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.games.push(gameInfo.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): scGameList {
    return { games: globalThis.Array.isArray(object?.games) ? object.games.map((e: any) => gameInfo.fromJSON(e)) : [] };
  },

  toJSON(message: scGameList): unknown {
    const obj: any = {};
    if (message.games?.length) {
      obj.games = message.games.map((e) => gameInfo.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<scGameList>, I>>(base?: I): scGameList {
    return scGameList.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<scGameList>, I>>(object: I): scGameList {
    const message = createBasescGameList();
    message.games = object.games?.map((e) => gameInfo.fromPartial(e)) || [];
    return message;
  },
};

function createBasegameInfo(): gameInfo {
  return { gameId: 0, gameName: "", sort: 0, kindId: 0, isRoom: 0, tag: 0, viplv: 0, gameType: 0 };
}

export const gameInfo: MessageFns<gameInfo> = {
  encode(message: gameInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.gameId !== 0) {
      writer.uint32(8).int32(message.gameId);
    }
    if (message.gameName !== "") {
      writer.uint32(18).string(message.gameName);
    }
    if (message.sort !== 0) {
      writer.uint32(24).int32(message.sort);
    }
    if (message.kindId !== 0) {
      writer.uint32(32).int32(message.kindId);
    }
    if (message.isRoom !== 0) {
      writer.uint32(40).int32(message.isRoom);
    }
    if (message.tag !== 0) {
      writer.uint32(48).int32(message.tag);
    }
    if (message.viplv !== 0) {
      writer.uint32(56).int32(message.viplv);
    }
    if (message.gameType !== 0) {
      writer.uint32(64).int32(message.gameType);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): gameInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasegameInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.gameId = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.gameName = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.sort = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.kindId = reader.int32();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.isRoom = reader.int32();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.tag = reader.int32();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.viplv = reader.int32();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.gameType = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): gameInfo {
    return {
      gameId: isSet(object.gameId) ? globalThis.Number(object.gameId) : 0,
      gameName: isSet(object.gameName) ? globalThis.String(object.gameName) : "",
      sort: isSet(object.sort) ? globalThis.Number(object.sort) : 0,
      kindId: isSet(object.kindId) ? globalThis.Number(object.kindId) : 0,
      isRoom: isSet(object.isRoom) ? globalThis.Number(object.isRoom) : 0,
      tag: isSet(object.tag) ? globalThis.Number(object.tag) : 0,
      viplv: isSet(object.viplv) ? globalThis.Number(object.viplv) : 0,
      gameType: isSet(object.gameType) ? globalThis.Number(object.gameType) : 0,
    };
  },

  toJSON(message: gameInfo): unknown {
    const obj: any = {};
    if (message.gameId !== 0) {
      obj.gameId = Math.round(message.gameId);
    }
    if (message.gameName !== "") {
      obj.gameName = message.gameName;
    }
    if (message.sort !== 0) {
      obj.sort = Math.round(message.sort);
    }
    if (message.kindId !== 0) {
      obj.kindId = Math.round(message.kindId);
    }
    if (message.isRoom !== 0) {
      obj.isRoom = Math.round(message.isRoom);
    }
    if (message.tag !== 0) {
      obj.tag = Math.round(message.tag);
    }
    if (message.viplv !== 0) {
      obj.viplv = Math.round(message.viplv);
    }
    if (message.gameType !== 0) {
      obj.gameType = Math.round(message.gameType);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<gameInfo>, I>>(base?: I): gameInfo {
    return gameInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<gameInfo>, I>>(object: I): gameInfo {
    const message = createBasegameInfo();
    message.gameId = object.gameId ?? 0;
    message.gameName = object.gameName ?? "";
    message.sort = object.sort ?? 0;
    message.kindId = object.kindId ?? 0;
    message.isRoom = object.isRoom ?? 0;
    message.tag = object.tag ?? 0;
    message.viplv = object.viplv ?? 0;
    message.gameType = object.gameType ?? 0;
    return message;
  },
};

function createBasenotifyGameJackport(): notifyGameJackport {
  return { gameId: 0, jackpot: 0 };
}

export const notifyGameJackport: MessageFns<notifyGameJackport> = {
  encode(message: notifyGameJackport, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.gameId !== 0) {
      writer.uint32(8).int32(message.gameId);
    }
    if (message.jackpot !== 0) {
      writer.uint32(16).int64(message.jackpot);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): notifyGameJackport {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasenotifyGameJackport();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.gameId = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.jackpot = longToNumber(reader.int64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): notifyGameJackport {
    return {
      gameId: isSet(object.gameId) ? globalThis.Number(object.gameId) : 0,
      jackpot: isSet(object.jackpot) ? globalThis.Number(object.jackpot) : 0,
    };
  },

  toJSON(message: notifyGameJackport): unknown {
    const obj: any = {};
    if (message.gameId !== 0) {
      obj.gameId = Math.round(message.gameId);
    }
    if (message.jackpot !== 0) {
      obj.jackpot = Math.round(message.jackpot);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<notifyGameJackport>, I>>(base?: I): notifyGameJackport {
    return notifyGameJackport.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<notifyGameJackport>, I>>(object: I): notifyGameJackport {
    const message = createBasenotifyGameJackport();
    message.gameId = object.gameId ?? 0;
    message.jackpot = object.jackpot ?? 0;
    return message;
  },
};

function createBasenotifyNeedEnterGame(): notifyNeedEnterGame {
  return { gameId: 0, roomId: 0 };
}

export const notifyNeedEnterGame: MessageFns<notifyNeedEnterGame> = {
  encode(message: notifyNeedEnterGame, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.gameId !== 0) {
      writer.uint32(8).int32(message.gameId);
    }
    if (message.roomId !== 0) {
      writer.uint32(16).int32(message.roomId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): notifyNeedEnterGame {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasenotifyNeedEnterGame();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.gameId = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.roomId = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): notifyNeedEnterGame {
    return {
      gameId: isSet(object.gameId) ? globalThis.Number(object.gameId) : 0,
      roomId: isSet(object.roomId) ? globalThis.Number(object.roomId) : 0,
    };
  },

  toJSON(message: notifyNeedEnterGame): unknown {
    const obj: any = {};
    if (message.gameId !== 0) {
      obj.gameId = Math.round(message.gameId);
    }
    if (message.roomId !== 0) {
      obj.roomId = Math.round(message.roomId);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<notifyNeedEnterGame>, I>>(base?: I): notifyNeedEnterGame {
    return notifyNeedEnterGame.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<notifyNeedEnterGame>, I>>(object: I): notifyNeedEnterGame {
    const message = createBasenotifyNeedEnterGame();
    message.gameId = object.gameId ?? 0;
    message.roomId = object.roomId ?? 0;
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function longToNumber(int64: { toString(): string }): number {
  const num = globalThis.Number(int64.toString());
  if (num > globalThis.Number.MAX_SAFE_INTEGER) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (num < globalThis.Number.MIN_SAFE_INTEGER) {
    throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return num;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
