// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.8.3
//   protoc               v6.33.0
// source: pb_lobby_withdraw.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";

export const protobufPackage = "pb_lobby_withdraw";

export interface csBankCardBindMsg {
  bankCardInfo: string;
  email: string;
}

export interface csBankCardWithdrawMsg {
  category: string;
  money: number;
  Password: string;
}

export interface csQueryUpiaccount {
  upiaccount: string;
}

/** Estrutura genérica do cartão/bind info */
export interface cardInfo {
  /** tipo do canal / forma de pagamento */
  type: string;
  /** identificador da conta ou número do cartão */
  account: string;
  /** JSON string com os dados do cartão */
  data: string;
}

/** Mensagem cliente -> servidor para atualizar cartão */
export interface csUpdateCardInfo {
  /** conta antiga */
  oldaccount: string;
  /** tipo antigo */
  oldtype: string;
  /** novo cartão */
  carddata:
    | cardInfo
    | undefined;
  /** código de verificação, se houver */
  verifyCode: string;
}

/** Mensagem servidor -> cliente com atualização de cartão */
export interface scUpdateCardInfo {
  /** lista de cartões vinculados */
  bankCardInfo: cardInfo[];
}

export interface scBankCardInfoMsg {
  bankCardInfo: string;
  MinWithDrawCoins: number;
  MinCoinsLeft: number;
  HitBet: number;
  transModeList: string;
  bBindEmail: boolean;
  transdaylimit: number;
  MaxWithDrawCoins: number;
  withdrawmul: number;
  fixbindCard: number;
  fixCode: number;
  feeRate: number;
  feeCount: number;
  firstbindcode: number;
}

export interface csBankWithdrawHistory {
  number: number;
  page: number;
}

export interface scBankWithdrawHistory {
  history: structBankWithdrawHistory[];
  page: number;
  maxnumber: number;
}

export interface structBankWithdrawHistory {
  /** número da transação */
  transNo: string;
  /** número do cartão */
  cardNo: string;
  /** quantidade de moedas */
  coins: number;
  /** timestamp da transação */
  timeStamp: number;
  /** estado (provável: 0=pendente, 1=aprovado, 2=rejeitado) */
  state: number;
  /** observação */
  remark: string;
}

export interface scBankCardWithdrawMsg {
  result: number;
  message: string;
}

function createBasecsBankCardBindMsg(): csBankCardBindMsg {
  return { bankCardInfo: "", email: "" };
}

export const csBankCardBindMsg: MessageFns<csBankCardBindMsg> = {
  encode(message: csBankCardBindMsg, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.bankCardInfo !== "") {
      writer.uint32(10).string(message.bankCardInfo);
    }
    if (message.email !== "") {
      writer.uint32(18).string(message.email);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): csBankCardBindMsg {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasecsBankCardBindMsg();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.bankCardInfo = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.email = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): csBankCardBindMsg {
    return {
      bankCardInfo: isSet(object.bankCardInfo) ? globalThis.String(object.bankCardInfo) : "",
      email: isSet(object.email) ? globalThis.String(object.email) : "",
    };
  },

  toJSON(message: csBankCardBindMsg): unknown {
    const obj: any = {};
    if (message.bankCardInfo !== "") {
      obj.bankCardInfo = message.bankCardInfo;
    }
    if (message.email !== "") {
      obj.email = message.email;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<csBankCardBindMsg>, I>>(base?: I): csBankCardBindMsg {
    return csBankCardBindMsg.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<csBankCardBindMsg>, I>>(object: I): csBankCardBindMsg {
    const message = createBasecsBankCardBindMsg();
    message.bankCardInfo = object.bankCardInfo ?? "";
    message.email = object.email ?? "";
    return message;
  },
};

function createBasecsBankCardWithdrawMsg(): csBankCardWithdrawMsg {
  return { category: "", money: 0, Password: "" };
}

export const csBankCardWithdrawMsg: MessageFns<csBankCardWithdrawMsg> = {
  encode(message: csBankCardWithdrawMsg, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.category !== "") {
      writer.uint32(10).string(message.category);
    }
    if (message.money !== 0) {
      writer.uint32(16).int64(message.money);
    }
    if (message.Password !== "") {
      writer.uint32(26).string(message.Password);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): csBankCardWithdrawMsg {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasecsBankCardWithdrawMsg();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.category = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.money = longToNumber(reader.int64());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.Password = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): csBankCardWithdrawMsg {
    return {
      category: isSet(object.category) ? globalThis.String(object.category) : "",
      money: isSet(object.money) ? globalThis.Number(object.money) : 0,
      Password: isSet(object.Password) ? globalThis.String(object.Password) : "",
    };
  },

  toJSON(message: csBankCardWithdrawMsg): unknown {
    const obj: any = {};
    if (message.category !== "") {
      obj.category = message.category;
    }
    if (message.money !== 0) {
      obj.money = Math.round(message.money);
    }
    if (message.Password !== "") {
      obj.Password = message.Password;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<csBankCardWithdrawMsg>, I>>(base?: I): csBankCardWithdrawMsg {
    return csBankCardWithdrawMsg.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<csBankCardWithdrawMsg>, I>>(object: I): csBankCardWithdrawMsg {
    const message = createBasecsBankCardWithdrawMsg();
    message.category = object.category ?? "";
    message.money = object.money ?? 0;
    message.Password = object.Password ?? "";
    return message;
  },
};

function createBasecsQueryUpiaccount(): csQueryUpiaccount {
  return { upiaccount: "" };
}

export const csQueryUpiaccount: MessageFns<csQueryUpiaccount> = {
  encode(message: csQueryUpiaccount, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.upiaccount !== "") {
      writer.uint32(10).string(message.upiaccount);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): csQueryUpiaccount {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasecsQueryUpiaccount();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.upiaccount = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): csQueryUpiaccount {
    return { upiaccount: isSet(object.upiaccount) ? globalThis.String(object.upiaccount) : "" };
  },

  toJSON(message: csQueryUpiaccount): unknown {
    const obj: any = {};
    if (message.upiaccount !== "") {
      obj.upiaccount = message.upiaccount;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<csQueryUpiaccount>, I>>(base?: I): csQueryUpiaccount {
    return csQueryUpiaccount.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<csQueryUpiaccount>, I>>(object: I): csQueryUpiaccount {
    const message = createBasecsQueryUpiaccount();
    message.upiaccount = object.upiaccount ?? "";
    return message;
  },
};

function createBasecardInfo(): cardInfo {
  return { type: "", account: "", data: "" };
}

export const cardInfo: MessageFns<cardInfo> = {
  encode(message: cardInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.type !== "") {
      writer.uint32(10).string(message.type);
    }
    if (message.account !== "") {
      writer.uint32(18).string(message.account);
    }
    if (message.data !== "") {
      writer.uint32(26).string(message.data);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): cardInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasecardInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.type = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.account = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.data = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): cardInfo {
    return {
      type: isSet(object.type) ? globalThis.String(object.type) : "",
      account: isSet(object.account) ? globalThis.String(object.account) : "",
      data: isSet(object.data) ? globalThis.String(object.data) : "",
    };
  },

  toJSON(message: cardInfo): unknown {
    const obj: any = {};
    if (message.type !== "") {
      obj.type = message.type;
    }
    if (message.account !== "") {
      obj.account = message.account;
    }
    if (message.data !== "") {
      obj.data = message.data;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<cardInfo>, I>>(base?: I): cardInfo {
    return cardInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<cardInfo>, I>>(object: I): cardInfo {
    const message = createBasecardInfo();
    message.type = object.type ?? "";
    message.account = object.account ?? "";
    message.data = object.data ?? "";
    return message;
  },
};

function createBasecsUpdateCardInfo(): csUpdateCardInfo {
  return { oldaccount: "", oldtype: "", carddata: undefined, verifyCode: "" };
}

export const csUpdateCardInfo: MessageFns<csUpdateCardInfo> = {
  encode(message: csUpdateCardInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.oldaccount !== "") {
      writer.uint32(10).string(message.oldaccount);
    }
    if (message.oldtype !== "") {
      writer.uint32(18).string(message.oldtype);
    }
    if (message.carddata !== undefined) {
      cardInfo.encode(message.carddata, writer.uint32(26).fork()).join();
    }
    if (message.verifyCode !== "") {
      writer.uint32(34).string(message.verifyCode);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): csUpdateCardInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasecsUpdateCardInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.oldaccount = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.oldtype = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.carddata = cardInfo.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.verifyCode = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): csUpdateCardInfo {
    return {
      oldaccount: isSet(object.oldaccount) ? globalThis.String(object.oldaccount) : "",
      oldtype: isSet(object.oldtype) ? globalThis.String(object.oldtype) : "",
      carddata: isSet(object.carddata) ? cardInfo.fromJSON(object.carddata) : undefined,
      verifyCode: isSet(object.verifyCode) ? globalThis.String(object.verifyCode) : "",
    };
  },

  toJSON(message: csUpdateCardInfo): unknown {
    const obj: any = {};
    if (message.oldaccount !== "") {
      obj.oldaccount = message.oldaccount;
    }
    if (message.oldtype !== "") {
      obj.oldtype = message.oldtype;
    }
    if (message.carddata !== undefined) {
      obj.carddata = cardInfo.toJSON(message.carddata);
    }
    if (message.verifyCode !== "") {
      obj.verifyCode = message.verifyCode;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<csUpdateCardInfo>, I>>(base?: I): csUpdateCardInfo {
    return csUpdateCardInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<csUpdateCardInfo>, I>>(object: I): csUpdateCardInfo {
    const message = createBasecsUpdateCardInfo();
    message.oldaccount = object.oldaccount ?? "";
    message.oldtype = object.oldtype ?? "";
    message.carddata = (object.carddata !== undefined && object.carddata !== null)
      ? cardInfo.fromPartial(object.carddata)
      : undefined;
    message.verifyCode = object.verifyCode ?? "";
    return message;
  },
};

function createBasescUpdateCardInfo(): scUpdateCardInfo {
  return { bankCardInfo: [] };
}

export const scUpdateCardInfo: MessageFns<scUpdateCardInfo> = {
  encode(message: scUpdateCardInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.bankCardInfo) {
      cardInfo.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): scUpdateCardInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasescUpdateCardInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.bankCardInfo.push(cardInfo.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): scUpdateCardInfo {
    return {
      bankCardInfo: globalThis.Array.isArray(object?.bankCardInfo)
        ? object.bankCardInfo.map((e: any) => cardInfo.fromJSON(e))
        : [],
    };
  },

  toJSON(message: scUpdateCardInfo): unknown {
    const obj: any = {};
    if (message.bankCardInfo?.length) {
      obj.bankCardInfo = message.bankCardInfo.map((e) => cardInfo.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<scUpdateCardInfo>, I>>(base?: I): scUpdateCardInfo {
    return scUpdateCardInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<scUpdateCardInfo>, I>>(object: I): scUpdateCardInfo {
    const message = createBasescUpdateCardInfo();
    message.bankCardInfo = object.bankCardInfo?.map((e) => cardInfo.fromPartial(e)) || [];
    return message;
  },
};

function createBasescBankCardInfoMsg(): scBankCardInfoMsg {
  return {
    bankCardInfo: "",
    MinWithDrawCoins: 0,
    MinCoinsLeft: 0,
    HitBet: 0,
    transModeList: "",
    bBindEmail: false,
    transdaylimit: 0,
    MaxWithDrawCoins: 0,
    withdrawmul: 0,
    fixbindCard: 0,
    fixCode: 0,
    feeRate: 0,
    feeCount: 0,
    firstbindcode: 0,
  };
}

export const scBankCardInfoMsg: MessageFns<scBankCardInfoMsg> = {
  encode(message: scBankCardInfoMsg, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.bankCardInfo !== "") {
      writer.uint32(10).string(message.bankCardInfo);
    }
    if (message.MinWithDrawCoins !== 0) {
      writer.uint32(16).int64(message.MinWithDrawCoins);
    }
    if (message.MinCoinsLeft !== 0) {
      writer.uint32(24).int64(message.MinCoinsLeft);
    }
    if (message.HitBet !== 0) {
      writer.uint32(32).int64(message.HitBet);
    }
    if (message.transModeList !== "") {
      writer.uint32(42).string(message.transModeList);
    }
    if (message.bBindEmail !== false) {
      writer.uint32(48).bool(message.bBindEmail);
    }
    if (message.transdaylimit !== 0) {
      writer.uint32(56).int32(message.transdaylimit);
    }
    if (message.MaxWithDrawCoins !== 0) {
      writer.uint32(64).int64(message.MaxWithDrawCoins);
    }
    if (message.withdrawmul !== 0) {
      writer.uint32(72).int32(message.withdrawmul);
    }
    if (message.fixbindCard !== 0) {
      writer.uint32(80).int32(message.fixbindCard);
    }
    if (message.fixCode !== 0) {
      writer.uint32(88).int32(message.fixCode);
    }
    if (message.feeRate !== 0) {
      writer.uint32(96).int32(message.feeRate);
    }
    if (message.feeCount !== 0) {
      writer.uint32(104).int32(message.feeCount);
    }
    if (message.firstbindcode !== 0) {
      writer.uint32(112).int32(message.firstbindcode);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): scBankCardInfoMsg {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasescBankCardInfoMsg();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.bankCardInfo = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.MinWithDrawCoins = longToNumber(reader.int64());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.MinCoinsLeft = longToNumber(reader.int64());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.HitBet = longToNumber(reader.int64());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.transModeList = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.bBindEmail = reader.bool();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.transdaylimit = reader.int32();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.MaxWithDrawCoins = longToNumber(reader.int64());
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.withdrawmul = reader.int32();
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.fixbindCard = reader.int32();
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.fixCode = reader.int32();
          continue;
        }
        case 12: {
          if (tag !== 96) {
            break;
          }

          message.feeRate = reader.int32();
          continue;
        }
        case 13: {
          if (tag !== 104) {
            break;
          }

          message.feeCount = reader.int32();
          continue;
        }
        case 14: {
          if (tag !== 112) {
            break;
          }

          message.firstbindcode = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): scBankCardInfoMsg {
    return {
      bankCardInfo: isSet(object.bankCardInfo) ? globalThis.String(object.bankCardInfo) : "",
      MinWithDrawCoins: isSet(object.MinWithDrawCoins) ? globalThis.Number(object.MinWithDrawCoins) : 0,
      MinCoinsLeft: isSet(object.MinCoinsLeft) ? globalThis.Number(object.MinCoinsLeft) : 0,
      HitBet: isSet(object.HitBet) ? globalThis.Number(object.HitBet) : 0,
      transModeList: isSet(object.transModeList) ? globalThis.String(object.transModeList) : "",
      bBindEmail: isSet(object.bBindEmail) ? globalThis.Boolean(object.bBindEmail) : false,
      transdaylimit: isSet(object.transdaylimit) ? globalThis.Number(object.transdaylimit) : 0,
      MaxWithDrawCoins: isSet(object.MaxWithDrawCoins) ? globalThis.Number(object.MaxWithDrawCoins) : 0,
      withdrawmul: isSet(object.withdrawmul) ? globalThis.Number(object.withdrawmul) : 0,
      fixbindCard: isSet(object.fixbindCard) ? globalThis.Number(object.fixbindCard) : 0,
      fixCode: isSet(object.fixCode) ? globalThis.Number(object.fixCode) : 0,
      feeRate: isSet(object.feeRate) ? globalThis.Number(object.feeRate) : 0,
      feeCount: isSet(object.feeCount) ? globalThis.Number(object.feeCount) : 0,
      firstbindcode: isSet(object.firstbindcode) ? globalThis.Number(object.firstbindcode) : 0,
    };
  },

  toJSON(message: scBankCardInfoMsg): unknown {
    const obj: any = {};
    if (message.bankCardInfo !== "") {
      obj.bankCardInfo = message.bankCardInfo;
    }
    if (message.MinWithDrawCoins !== 0) {
      obj.MinWithDrawCoins = Math.round(message.MinWithDrawCoins);
    }
    if (message.MinCoinsLeft !== 0) {
      obj.MinCoinsLeft = Math.round(message.MinCoinsLeft);
    }
    if (message.HitBet !== 0) {
      obj.HitBet = Math.round(message.HitBet);
    }
    if (message.transModeList !== "") {
      obj.transModeList = message.transModeList;
    }
    if (message.bBindEmail !== false) {
      obj.bBindEmail = message.bBindEmail;
    }
    if (message.transdaylimit !== 0) {
      obj.transdaylimit = Math.round(message.transdaylimit);
    }
    if (message.MaxWithDrawCoins !== 0) {
      obj.MaxWithDrawCoins = Math.round(message.MaxWithDrawCoins);
    }
    if (message.withdrawmul !== 0) {
      obj.withdrawmul = Math.round(message.withdrawmul);
    }
    if (message.fixbindCard !== 0) {
      obj.fixbindCard = Math.round(message.fixbindCard);
    }
    if (message.fixCode !== 0) {
      obj.fixCode = Math.round(message.fixCode);
    }
    if (message.feeRate !== 0) {
      obj.feeRate = Math.round(message.feeRate);
    }
    if (message.feeCount !== 0) {
      obj.feeCount = Math.round(message.feeCount);
    }
    if (message.firstbindcode !== 0) {
      obj.firstbindcode = Math.round(message.firstbindcode);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<scBankCardInfoMsg>, I>>(base?: I): scBankCardInfoMsg {
    return scBankCardInfoMsg.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<scBankCardInfoMsg>, I>>(object: I): scBankCardInfoMsg {
    const message = createBasescBankCardInfoMsg();
    message.bankCardInfo = object.bankCardInfo ?? "";
    message.MinWithDrawCoins = object.MinWithDrawCoins ?? 0;
    message.MinCoinsLeft = object.MinCoinsLeft ?? 0;
    message.HitBet = object.HitBet ?? 0;
    message.transModeList = object.transModeList ?? "";
    message.bBindEmail = object.bBindEmail ?? false;
    message.transdaylimit = object.transdaylimit ?? 0;
    message.MaxWithDrawCoins = object.MaxWithDrawCoins ?? 0;
    message.withdrawmul = object.withdrawmul ?? 0;
    message.fixbindCard = object.fixbindCard ?? 0;
    message.fixCode = object.fixCode ?? 0;
    message.feeRate = object.feeRate ?? 0;
    message.feeCount = object.feeCount ?? 0;
    message.firstbindcode = object.firstbindcode ?? 0;
    return message;
  },
};

function createBasecsBankWithdrawHistory(): csBankWithdrawHistory {
  return { number: 0, page: 0 };
}

export const csBankWithdrawHistory: MessageFns<csBankWithdrawHistory> = {
  encode(message: csBankWithdrawHistory, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.number !== 0) {
      writer.uint32(8).int32(message.number);
    }
    if (message.page !== 0) {
      writer.uint32(16).int32(message.page);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): csBankWithdrawHistory {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasecsBankWithdrawHistory();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.number = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.page = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): csBankWithdrawHistory {
    return {
      number: isSet(object.number) ? globalThis.Number(object.number) : 0,
      page: isSet(object.page) ? globalThis.Number(object.page) : 0,
    };
  },

  toJSON(message: csBankWithdrawHistory): unknown {
    const obj: any = {};
    if (message.number !== 0) {
      obj.number = Math.round(message.number);
    }
    if (message.page !== 0) {
      obj.page = Math.round(message.page);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<csBankWithdrawHistory>, I>>(base?: I): csBankWithdrawHistory {
    return csBankWithdrawHistory.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<csBankWithdrawHistory>, I>>(object: I): csBankWithdrawHistory {
    const message = createBasecsBankWithdrawHistory();
    message.number = object.number ?? 0;
    message.page = object.page ?? 0;
    return message;
  },
};

function createBasescBankWithdrawHistory(): scBankWithdrawHistory {
  return { history: [], page: 0, maxnumber: 0 };
}

export const scBankWithdrawHistory: MessageFns<scBankWithdrawHistory> = {
  encode(message: scBankWithdrawHistory, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.history) {
      structBankWithdrawHistory.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.page !== 0) {
      writer.uint32(16).int32(message.page);
    }
    if (message.maxnumber !== 0) {
      writer.uint32(24).int32(message.maxnumber);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): scBankWithdrawHistory {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasescBankWithdrawHistory();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.history.push(structBankWithdrawHistory.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.page = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.maxnumber = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): scBankWithdrawHistory {
    return {
      history: globalThis.Array.isArray(object?.history)
        ? object.history.map((e: any) => structBankWithdrawHistory.fromJSON(e))
        : [],
      page: isSet(object.page) ? globalThis.Number(object.page) : 0,
      maxnumber: isSet(object.maxnumber) ? globalThis.Number(object.maxnumber) : 0,
    };
  },

  toJSON(message: scBankWithdrawHistory): unknown {
    const obj: any = {};
    if (message.history?.length) {
      obj.history = message.history.map((e) => structBankWithdrawHistory.toJSON(e));
    }
    if (message.page !== 0) {
      obj.page = Math.round(message.page);
    }
    if (message.maxnumber !== 0) {
      obj.maxnumber = Math.round(message.maxnumber);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<scBankWithdrawHistory>, I>>(base?: I): scBankWithdrawHistory {
    return scBankWithdrawHistory.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<scBankWithdrawHistory>, I>>(object: I): scBankWithdrawHistory {
    const message = createBasescBankWithdrawHistory();
    message.history = object.history?.map((e) => structBankWithdrawHistory.fromPartial(e)) || [];
    message.page = object.page ?? 0;
    message.maxnumber = object.maxnumber ?? 0;
    return message;
  },
};

function createBasestructBankWithdrawHistory(): structBankWithdrawHistory {
  return { transNo: "", cardNo: "", coins: 0, timeStamp: 0, state: 0, remark: "" };
}

export const structBankWithdrawHistory: MessageFns<structBankWithdrawHistory> = {
  encode(message: structBankWithdrawHistory, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.transNo !== "") {
      writer.uint32(10).string(message.transNo);
    }
    if (message.cardNo !== "") {
      writer.uint32(18).string(message.cardNo);
    }
    if (message.coins !== 0) {
      writer.uint32(24).int64(message.coins);
    }
    if (message.timeStamp !== 0) {
      writer.uint32(32).int64(message.timeStamp);
    }
    if (message.state !== 0) {
      writer.uint32(40).int32(message.state);
    }
    if (message.remark !== "") {
      writer.uint32(50).string(message.remark);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): structBankWithdrawHistory {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasestructBankWithdrawHistory();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.transNo = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.cardNo = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.coins = longToNumber(reader.int64());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.timeStamp = longToNumber(reader.int64());
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.state = reader.int32();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.remark = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): structBankWithdrawHistory {
    return {
      transNo: isSet(object.transNo) ? globalThis.String(object.transNo) : "",
      cardNo: isSet(object.cardNo) ? globalThis.String(object.cardNo) : "",
      coins: isSet(object.coins) ? globalThis.Number(object.coins) : 0,
      timeStamp: isSet(object.timeStamp) ? globalThis.Number(object.timeStamp) : 0,
      state: isSet(object.state) ? globalThis.Number(object.state) : 0,
      remark: isSet(object.remark) ? globalThis.String(object.remark) : "",
    };
  },

  toJSON(message: structBankWithdrawHistory): unknown {
    const obj: any = {};
    if (message.transNo !== "") {
      obj.transNo = message.transNo;
    }
    if (message.cardNo !== "") {
      obj.cardNo = message.cardNo;
    }
    if (message.coins !== 0) {
      obj.coins = Math.round(message.coins);
    }
    if (message.timeStamp !== 0) {
      obj.timeStamp = Math.round(message.timeStamp);
    }
    if (message.state !== 0) {
      obj.state = Math.round(message.state);
    }
    if (message.remark !== "") {
      obj.remark = message.remark;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<structBankWithdrawHistory>, I>>(base?: I): structBankWithdrawHistory {
    return structBankWithdrawHistory.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<structBankWithdrawHistory>, I>>(object: I): structBankWithdrawHistory {
    const message = createBasestructBankWithdrawHistory();
    message.transNo = object.transNo ?? "";
    message.cardNo = object.cardNo ?? "";
    message.coins = object.coins ?? 0;
    message.timeStamp = object.timeStamp ?? 0;
    message.state = object.state ?? 0;
    message.remark = object.remark ?? "";
    return message;
  },
};

function createBasescBankCardWithdrawMsg(): scBankCardWithdrawMsg {
  return { result: 0, message: "" };
}

export const scBankCardWithdrawMsg: MessageFns<scBankCardWithdrawMsg> = {
  encode(message: scBankCardWithdrawMsg, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.result !== 0) {
      writer.uint32(8).int32(message.result);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): scBankCardWithdrawMsg {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasescBankCardWithdrawMsg();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.result = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): scBankCardWithdrawMsg {
    return {
      result: isSet(object.result) ? globalThis.Number(object.result) : 0,
      message: isSet(object.message) ? globalThis.String(object.message) : "",
    };
  },

  toJSON(message: scBankCardWithdrawMsg): unknown {
    const obj: any = {};
    if (message.result !== 0) {
      obj.result = Math.round(message.result);
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<scBankCardWithdrawMsg>, I>>(base?: I): scBankCardWithdrawMsg {
    return scBankCardWithdrawMsg.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<scBankCardWithdrawMsg>, I>>(object: I): scBankCardWithdrawMsg {
    const message = createBasescBankCardWithdrawMsg();
    message.result = object.result ?? 0;
    message.message = object.message ?? "";
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function longToNumber(int64: { toString(): string }): number {
  const num = globalThis.Number(int64.toString());
  if (num > globalThis.Number.MAX_SAFE_INTEGER) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (num < globalThis.Number.MIN_SAFE_INTEGER) {
    throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return num;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
