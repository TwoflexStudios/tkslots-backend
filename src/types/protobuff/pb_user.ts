// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.8.3
//   protoc               v6.33.0
// source: pb_user.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";

export const protobufPackage = "pb_user";

export interface csUserLoginHall {
  ab: number;
  account: string;
  password: string;
  deviceCode: string;
  deviceType: number;
}

export interface scUserLoginHall {
  uid: number;
  name: string;
  money: number;
  userLevel: number;
  vipLevel: number;
  userExp: number;
  session: string;
  logoId: number;
  vipExp: number;
  lan: string;
  phoneNo: string;
  areaCode: string;
  bFirstRecharge: number;
  bBindSourceId: number;
  RealName: string;
  Email: string;
}

export interface csUserSessionLogin {
  uid: number;
  deviceCode: string;
  session: string;
}

export interface notifyUserinfoUpdate {
  money: number;
  bankMoney: number;
  vipLevel: number;
  vipExp: number;
  name: string;
  logoId: number;
  type: number;
  changed: number;
  phoneNo: string;
  areaCode: string;
}

export interface notifyUserRechargeResultInfo {
  firstRecharge: number;
  rechargeCoins: number;
  rechargeCash: number;
}

export interface csRegistAccount {
  account: string;
  password: string;
  deviceCode: string;
  deviceType: number;
  registerType: number;
  lan: string;
  sourceUserId: number;
  sourceChannel: number;
}

export interface scConnectSuccess {
  maxVer: string;
  lessVer: string;
  reserVe0: string;
  reserVe1: string;
  checkCode: string;
}

function createBasecsUserLoginHall(): csUserLoginHall {
  return { ab: 0, account: "", password: "", deviceCode: "", deviceType: 0 };
}

export const csUserLoginHall: MessageFns<csUserLoginHall> = {
  encode(message: csUserLoginHall, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.ab !== 0) {
      writer.uint32(8).int32(message.ab);
    }
    if (message.account !== "") {
      writer.uint32(18).string(message.account);
    }
    if (message.password !== "") {
      writer.uint32(26).string(message.password);
    }
    if (message.deviceCode !== "") {
      writer.uint32(34).string(message.deviceCode);
    }
    if (message.deviceType !== 0) {
      writer.uint32(40).int32(message.deviceType);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): csUserLoginHall {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasecsUserLoginHall();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.ab = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.account = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.password = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.deviceCode = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.deviceType = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): csUserLoginHall {
    return {
      ab: isSet(object.ab) ? globalThis.Number(object.ab) : 0,
      account: isSet(object.account) ? globalThis.String(object.account) : "",
      password: isSet(object.password) ? globalThis.String(object.password) : "",
      deviceCode: isSet(object.deviceCode) ? globalThis.String(object.deviceCode) : "",
      deviceType: isSet(object.deviceType) ? globalThis.Number(object.deviceType) : 0,
    };
  },

  toJSON(message: csUserLoginHall): unknown {
    const obj: any = {};
    if (message.ab !== 0) {
      obj.ab = Math.round(message.ab);
    }
    if (message.account !== "") {
      obj.account = message.account;
    }
    if (message.password !== "") {
      obj.password = message.password;
    }
    if (message.deviceCode !== "") {
      obj.deviceCode = message.deviceCode;
    }
    if (message.deviceType !== 0) {
      obj.deviceType = Math.round(message.deviceType);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<csUserLoginHall>, I>>(base?: I): csUserLoginHall {
    return csUserLoginHall.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<csUserLoginHall>, I>>(object: I): csUserLoginHall {
    const message = createBasecsUserLoginHall();
    message.ab = object.ab ?? 0;
    message.account = object.account ?? "";
    message.password = object.password ?? "";
    message.deviceCode = object.deviceCode ?? "";
    message.deviceType = object.deviceType ?? 0;
    return message;
  },
};

function createBasescUserLoginHall(): scUserLoginHall {
  return {
    uid: 0,
    name: "",
    money: 0,
    userLevel: 0,
    vipLevel: 0,
    userExp: 0,
    session: "",
    logoId: 0,
    vipExp: 0,
    lan: "",
    phoneNo: "",
    areaCode: "",
    bFirstRecharge: 0,
    bBindSourceId: 0,
    RealName: "",
    Email: "",
  };
}

export const scUserLoginHall: MessageFns<scUserLoginHall> = {
  encode(message: scUserLoginHall, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.uid !== 0) {
      writer.uint32(8).int32(message.uid);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.money !== 0) {
      writer.uint32(24).int64(message.money);
    }
    if (message.userLevel !== 0) {
      writer.uint32(32).int32(message.userLevel);
    }
    if (message.vipLevel !== 0) {
      writer.uint32(40).int32(message.vipLevel);
    }
    if (message.userExp !== 0) {
      writer.uint32(48).int64(message.userExp);
    }
    if (message.session !== "") {
      writer.uint32(58).string(message.session);
    }
    if (message.logoId !== 0) {
      writer.uint32(64).int32(message.logoId);
    }
    if (message.vipExp !== 0) {
      writer.uint32(72).int64(message.vipExp);
    }
    if (message.lan !== "") {
      writer.uint32(82).string(message.lan);
    }
    if (message.phoneNo !== "") {
      writer.uint32(90).string(message.phoneNo);
    }
    if (message.areaCode !== "") {
      writer.uint32(98).string(message.areaCode);
    }
    if (message.bFirstRecharge !== 0) {
      writer.uint32(104).int32(message.bFirstRecharge);
    }
    if (message.bBindSourceId !== 0) {
      writer.uint32(112).int32(message.bBindSourceId);
    }
    if (message.RealName !== "") {
      writer.uint32(122).string(message.RealName);
    }
    if (message.Email !== "") {
      writer.uint32(130).string(message.Email);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): scUserLoginHall {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasescUserLoginHall();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.uid = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.money = longToNumber(reader.int64());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.userLevel = reader.int32();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.vipLevel = reader.int32();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.userExp = longToNumber(reader.int64());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.session = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.logoId = reader.int32();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.vipExp = longToNumber(reader.int64());
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.lan = reader.string();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.phoneNo = reader.string();
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.areaCode = reader.string();
          continue;
        }
        case 13: {
          if (tag !== 104) {
            break;
          }

          message.bFirstRecharge = reader.int32();
          continue;
        }
        case 14: {
          if (tag !== 112) {
            break;
          }

          message.bBindSourceId = reader.int32();
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.RealName = reader.string();
          continue;
        }
        case 16: {
          if (tag !== 130) {
            break;
          }

          message.Email = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): scUserLoginHall {
    return {
      uid: isSet(object.uid) ? globalThis.Number(object.uid) : 0,
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      money: isSet(object.money) ? globalThis.Number(object.money) : 0,
      userLevel: isSet(object.userLevel) ? globalThis.Number(object.userLevel) : 0,
      vipLevel: isSet(object.vipLevel) ? globalThis.Number(object.vipLevel) : 0,
      userExp: isSet(object.userExp) ? globalThis.Number(object.userExp) : 0,
      session: isSet(object.session) ? globalThis.String(object.session) : "",
      logoId: isSet(object.logoId) ? globalThis.Number(object.logoId) : 0,
      vipExp: isSet(object.vipExp) ? globalThis.Number(object.vipExp) : 0,
      lan: isSet(object.lan) ? globalThis.String(object.lan) : "",
      phoneNo: isSet(object.phoneNo) ? globalThis.String(object.phoneNo) : "",
      areaCode: isSet(object.areaCode) ? globalThis.String(object.areaCode) : "",
      bFirstRecharge: isSet(object.bFirstRecharge) ? globalThis.Number(object.bFirstRecharge) : 0,
      bBindSourceId: isSet(object.bBindSourceId) ? globalThis.Number(object.bBindSourceId) : 0,
      RealName: isSet(object.RealName) ? globalThis.String(object.RealName) : "",
      Email: isSet(object.Email) ? globalThis.String(object.Email) : "",
    };
  },

  toJSON(message: scUserLoginHall): unknown {
    const obj: any = {};
    if (message.uid !== 0) {
      obj.uid = Math.round(message.uid);
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.money !== 0) {
      obj.money = Math.round(message.money);
    }
    if (message.userLevel !== 0) {
      obj.userLevel = Math.round(message.userLevel);
    }
    if (message.vipLevel !== 0) {
      obj.vipLevel = Math.round(message.vipLevel);
    }
    if (message.userExp !== 0) {
      obj.userExp = Math.round(message.userExp);
    }
    if (message.session !== "") {
      obj.session = message.session;
    }
    if (message.logoId !== 0) {
      obj.logoId = Math.round(message.logoId);
    }
    if (message.vipExp !== 0) {
      obj.vipExp = Math.round(message.vipExp);
    }
    if (message.lan !== "") {
      obj.lan = message.lan;
    }
    if (message.phoneNo !== "") {
      obj.phoneNo = message.phoneNo;
    }
    if (message.areaCode !== "") {
      obj.areaCode = message.areaCode;
    }
    if (message.bFirstRecharge !== 0) {
      obj.bFirstRecharge = Math.round(message.bFirstRecharge);
    }
    if (message.bBindSourceId !== 0) {
      obj.bBindSourceId = Math.round(message.bBindSourceId);
    }
    if (message.RealName !== "") {
      obj.RealName = message.RealName;
    }
    if (message.Email !== "") {
      obj.Email = message.Email;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<scUserLoginHall>, I>>(base?: I): scUserLoginHall {
    return scUserLoginHall.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<scUserLoginHall>, I>>(object: I): scUserLoginHall {
    const message = createBasescUserLoginHall();
    message.uid = object.uid ?? 0;
    message.name = object.name ?? "";
    message.money = object.money ?? 0;
    message.userLevel = object.userLevel ?? 0;
    message.vipLevel = object.vipLevel ?? 0;
    message.userExp = object.userExp ?? 0;
    message.session = object.session ?? "";
    message.logoId = object.logoId ?? 0;
    message.vipExp = object.vipExp ?? 0;
    message.lan = object.lan ?? "";
    message.phoneNo = object.phoneNo ?? "";
    message.areaCode = object.areaCode ?? "";
    message.bFirstRecharge = object.bFirstRecharge ?? 0;
    message.bBindSourceId = object.bBindSourceId ?? 0;
    message.RealName = object.RealName ?? "";
    message.Email = object.Email ?? "";
    return message;
  },
};

function createBasecsUserSessionLogin(): csUserSessionLogin {
  return { uid: 0, deviceCode: "", session: "" };
}

export const csUserSessionLogin: MessageFns<csUserSessionLogin> = {
  encode(message: csUserSessionLogin, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.uid !== 0) {
      writer.uint32(8).int32(message.uid);
    }
    if (message.deviceCode !== "") {
      writer.uint32(18).string(message.deviceCode);
    }
    if (message.session !== "") {
      writer.uint32(26).string(message.session);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): csUserSessionLogin {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasecsUserSessionLogin();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.uid = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.deviceCode = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.session = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): csUserSessionLogin {
    return {
      uid: isSet(object.uid) ? globalThis.Number(object.uid) : 0,
      deviceCode: isSet(object.deviceCode) ? globalThis.String(object.deviceCode) : "",
      session: isSet(object.session) ? globalThis.String(object.session) : "",
    };
  },

  toJSON(message: csUserSessionLogin): unknown {
    const obj: any = {};
    if (message.uid !== 0) {
      obj.uid = Math.round(message.uid);
    }
    if (message.deviceCode !== "") {
      obj.deviceCode = message.deviceCode;
    }
    if (message.session !== "") {
      obj.session = message.session;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<csUserSessionLogin>, I>>(base?: I): csUserSessionLogin {
    return csUserSessionLogin.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<csUserSessionLogin>, I>>(object: I): csUserSessionLogin {
    const message = createBasecsUserSessionLogin();
    message.uid = object.uid ?? 0;
    message.deviceCode = object.deviceCode ?? "";
    message.session = object.session ?? "";
    return message;
  },
};

function createBasenotifyUserinfoUpdate(): notifyUserinfoUpdate {
  return {
    money: 0,
    bankMoney: 0,
    vipLevel: 0,
    vipExp: 0,
    name: "",
    logoId: 0,
    type: 0,
    changed: 0,
    phoneNo: "",
    areaCode: "",
  };
}

export const notifyUserinfoUpdate: MessageFns<notifyUserinfoUpdate> = {
  encode(message: notifyUserinfoUpdate, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.money !== 0) {
      writer.uint32(8).int64(message.money);
    }
    if (message.bankMoney !== 0) {
      writer.uint32(16).int64(message.bankMoney);
    }
    if (message.vipLevel !== 0) {
      writer.uint32(24).int32(message.vipLevel);
    }
    if (message.vipExp !== 0) {
      writer.uint32(32).int64(message.vipExp);
    }
    if (message.name !== "") {
      writer.uint32(42).string(message.name);
    }
    if (message.logoId !== 0) {
      writer.uint32(48).int32(message.logoId);
    }
    if (message.type !== 0) {
      writer.uint32(56).int32(message.type);
    }
    if (message.changed !== 0) {
      writer.uint32(64).int64(message.changed);
    }
    if (message.phoneNo !== "") {
      writer.uint32(74).string(message.phoneNo);
    }
    if (message.areaCode !== "") {
      writer.uint32(82).string(message.areaCode);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): notifyUserinfoUpdate {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasenotifyUserinfoUpdate();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.money = longToNumber(reader.int64());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.bankMoney = longToNumber(reader.int64());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.vipLevel = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.vipExp = longToNumber(reader.int64());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.logoId = reader.int32();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.type = reader.int32();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.changed = longToNumber(reader.int64());
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.phoneNo = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.areaCode = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): notifyUserinfoUpdate {
    return {
      money: isSet(object.money) ? globalThis.Number(object.money) : 0,
      bankMoney: isSet(object.bankMoney) ? globalThis.Number(object.bankMoney) : 0,
      vipLevel: isSet(object.vipLevel) ? globalThis.Number(object.vipLevel) : 0,
      vipExp: isSet(object.vipExp) ? globalThis.Number(object.vipExp) : 0,
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      logoId: isSet(object.logoId) ? globalThis.Number(object.logoId) : 0,
      type: isSet(object.type) ? globalThis.Number(object.type) : 0,
      changed: isSet(object.changed) ? globalThis.Number(object.changed) : 0,
      phoneNo: isSet(object.phoneNo) ? globalThis.String(object.phoneNo) : "",
      areaCode: isSet(object.areaCode) ? globalThis.String(object.areaCode) : "",
    };
  },

  toJSON(message: notifyUserinfoUpdate): unknown {
    const obj: any = {};
    if (message.money !== 0) {
      obj.money = Math.round(message.money);
    }
    if (message.bankMoney !== 0) {
      obj.bankMoney = Math.round(message.bankMoney);
    }
    if (message.vipLevel !== 0) {
      obj.vipLevel = Math.round(message.vipLevel);
    }
    if (message.vipExp !== 0) {
      obj.vipExp = Math.round(message.vipExp);
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.logoId !== 0) {
      obj.logoId = Math.round(message.logoId);
    }
    if (message.type !== 0) {
      obj.type = Math.round(message.type);
    }
    if (message.changed !== 0) {
      obj.changed = Math.round(message.changed);
    }
    if (message.phoneNo !== "") {
      obj.phoneNo = message.phoneNo;
    }
    if (message.areaCode !== "") {
      obj.areaCode = message.areaCode;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<notifyUserinfoUpdate>, I>>(base?: I): notifyUserinfoUpdate {
    return notifyUserinfoUpdate.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<notifyUserinfoUpdate>, I>>(object: I): notifyUserinfoUpdate {
    const message = createBasenotifyUserinfoUpdate();
    message.money = object.money ?? 0;
    message.bankMoney = object.bankMoney ?? 0;
    message.vipLevel = object.vipLevel ?? 0;
    message.vipExp = object.vipExp ?? 0;
    message.name = object.name ?? "";
    message.logoId = object.logoId ?? 0;
    message.type = object.type ?? 0;
    message.changed = object.changed ?? 0;
    message.phoneNo = object.phoneNo ?? "";
    message.areaCode = object.areaCode ?? "";
    return message;
  },
};

function createBasenotifyUserRechargeResultInfo(): notifyUserRechargeResultInfo {
  return { firstRecharge: 0, rechargeCoins: 0, rechargeCash: 0 };
}

export const notifyUserRechargeResultInfo: MessageFns<notifyUserRechargeResultInfo> = {
  encode(message: notifyUserRechargeResultInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.firstRecharge !== 0) {
      writer.uint32(8).int32(message.firstRecharge);
    }
    if (message.rechargeCoins !== 0) {
      writer.uint32(16).int64(message.rechargeCoins);
    }
    if (message.rechargeCash !== 0) {
      writer.uint32(24).int64(message.rechargeCash);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): notifyUserRechargeResultInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasenotifyUserRechargeResultInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.firstRecharge = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.rechargeCoins = longToNumber(reader.int64());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.rechargeCash = longToNumber(reader.int64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): notifyUserRechargeResultInfo {
    return {
      firstRecharge: isSet(object.firstRecharge) ? globalThis.Number(object.firstRecharge) : 0,
      rechargeCoins: isSet(object.rechargeCoins) ? globalThis.Number(object.rechargeCoins) : 0,
      rechargeCash: isSet(object.rechargeCash) ? globalThis.Number(object.rechargeCash) : 0,
    };
  },

  toJSON(message: notifyUserRechargeResultInfo): unknown {
    const obj: any = {};
    if (message.firstRecharge !== 0) {
      obj.firstRecharge = Math.round(message.firstRecharge);
    }
    if (message.rechargeCoins !== 0) {
      obj.rechargeCoins = Math.round(message.rechargeCoins);
    }
    if (message.rechargeCash !== 0) {
      obj.rechargeCash = Math.round(message.rechargeCash);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<notifyUserRechargeResultInfo>, I>>(base?: I): notifyUserRechargeResultInfo {
    return notifyUserRechargeResultInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<notifyUserRechargeResultInfo>, I>>(object: I): notifyUserRechargeResultInfo {
    const message = createBasenotifyUserRechargeResultInfo();
    message.firstRecharge = object.firstRecharge ?? 0;
    message.rechargeCoins = object.rechargeCoins ?? 0;
    message.rechargeCash = object.rechargeCash ?? 0;
    return message;
  },
};

function createBasecsRegistAccount(): csRegistAccount {
  return {
    account: "",
    password: "",
    deviceCode: "",
    deviceType: 0,
    registerType: 0,
    lan: "",
    sourceUserId: 0,
    sourceChannel: 0,
  };
}

export const csRegistAccount: MessageFns<csRegistAccount> = {
  encode(message: csRegistAccount, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.account !== "") {
      writer.uint32(10).string(message.account);
    }
    if (message.password !== "") {
      writer.uint32(18).string(message.password);
    }
    if (message.deviceCode !== "") {
      writer.uint32(26).string(message.deviceCode);
    }
    if (message.deviceType !== 0) {
      writer.uint32(32).int32(message.deviceType);
    }
    if (message.registerType !== 0) {
      writer.uint32(40).int32(message.registerType);
    }
    if (message.lan !== "") {
      writer.uint32(50).string(message.lan);
    }
    if (message.sourceUserId !== 0) {
      writer.uint32(56).int32(message.sourceUserId);
    }
    if (message.sourceChannel !== 0) {
      writer.uint32(64).int32(message.sourceChannel);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): csRegistAccount {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasecsRegistAccount();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.account = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.password = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.deviceCode = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.deviceType = reader.int32();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.registerType = reader.int32();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.lan = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.sourceUserId = reader.int32();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.sourceChannel = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): csRegistAccount {
    return {
      account: isSet(object.account) ? globalThis.String(object.account) : "",
      password: isSet(object.password) ? globalThis.String(object.password) : "",
      deviceCode: isSet(object.deviceCode) ? globalThis.String(object.deviceCode) : "",
      deviceType: isSet(object.deviceType) ? globalThis.Number(object.deviceType) : 0,
      registerType: isSet(object.registerType) ? globalThis.Number(object.registerType) : 0,
      lan: isSet(object.lan) ? globalThis.String(object.lan) : "",
      sourceUserId: isSet(object.sourceUserId) ? globalThis.Number(object.sourceUserId) : 0,
      sourceChannel: isSet(object.sourceChannel) ? globalThis.Number(object.sourceChannel) : 0,
    };
  },

  toJSON(message: csRegistAccount): unknown {
    const obj: any = {};
    if (message.account !== "") {
      obj.account = message.account;
    }
    if (message.password !== "") {
      obj.password = message.password;
    }
    if (message.deviceCode !== "") {
      obj.deviceCode = message.deviceCode;
    }
    if (message.deviceType !== 0) {
      obj.deviceType = Math.round(message.deviceType);
    }
    if (message.registerType !== 0) {
      obj.registerType = Math.round(message.registerType);
    }
    if (message.lan !== "") {
      obj.lan = message.lan;
    }
    if (message.sourceUserId !== 0) {
      obj.sourceUserId = Math.round(message.sourceUserId);
    }
    if (message.sourceChannel !== 0) {
      obj.sourceChannel = Math.round(message.sourceChannel);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<csRegistAccount>, I>>(base?: I): csRegistAccount {
    return csRegistAccount.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<csRegistAccount>, I>>(object: I): csRegistAccount {
    const message = createBasecsRegistAccount();
    message.account = object.account ?? "";
    message.password = object.password ?? "";
    message.deviceCode = object.deviceCode ?? "";
    message.deviceType = object.deviceType ?? 0;
    message.registerType = object.registerType ?? 0;
    message.lan = object.lan ?? "";
    message.sourceUserId = object.sourceUserId ?? 0;
    message.sourceChannel = object.sourceChannel ?? 0;
    return message;
  },
};

function createBasescConnectSuccess(): scConnectSuccess {
  return { maxVer: "", lessVer: "", reserVe0: "", reserVe1: "", checkCode: "" };
}

export const scConnectSuccess: MessageFns<scConnectSuccess> = {
  encode(message: scConnectSuccess, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.maxVer !== "") {
      writer.uint32(10).string(message.maxVer);
    }
    if (message.lessVer !== "") {
      writer.uint32(18).string(message.lessVer);
    }
    if (message.reserVe0 !== "") {
      writer.uint32(26).string(message.reserVe0);
    }
    if (message.reserVe1 !== "") {
      writer.uint32(34).string(message.reserVe1);
    }
    if (message.checkCode !== "") {
      writer.uint32(42).string(message.checkCode);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): scConnectSuccess {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasescConnectSuccess();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.maxVer = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.lessVer = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.reserVe0 = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.reserVe1 = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.checkCode = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): scConnectSuccess {
    return {
      maxVer: isSet(object.maxVer) ? globalThis.String(object.maxVer) : "",
      lessVer: isSet(object.lessVer) ? globalThis.String(object.lessVer) : "",
      reserVe0: isSet(object.reserVe0) ? globalThis.String(object.reserVe0) : "",
      reserVe1: isSet(object.reserVe1) ? globalThis.String(object.reserVe1) : "",
      checkCode: isSet(object.checkCode) ? globalThis.String(object.checkCode) : "",
    };
  },

  toJSON(message: scConnectSuccess): unknown {
    const obj: any = {};
    if (message.maxVer !== "") {
      obj.maxVer = message.maxVer;
    }
    if (message.lessVer !== "") {
      obj.lessVer = message.lessVer;
    }
    if (message.reserVe0 !== "") {
      obj.reserVe0 = message.reserVe0;
    }
    if (message.reserVe1 !== "") {
      obj.reserVe1 = message.reserVe1;
    }
    if (message.checkCode !== "") {
      obj.checkCode = message.checkCode;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<scConnectSuccess>, I>>(base?: I): scConnectSuccess {
    return scConnectSuccess.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<scConnectSuccess>, I>>(object: I): scConnectSuccess {
    const message = createBasescConnectSuccess();
    message.maxVer = object.maxVer ?? "";
    message.lessVer = object.lessVer ?? "";
    message.reserVe0 = object.reserVe0 ?? "";
    message.reserVe1 = object.reserVe1 ?? "";
    message.checkCode = object.checkCode ?? "";
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function longToNumber(int64: { toString(): string }): number {
  const num = globalThis.Number(int64.toString());
  if (num > globalThis.Number.MAX_SAFE_INTEGER) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (num < globalThis.Number.MIN_SAFE_INTEGER) {
    throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return num;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
