// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.8.3
//   protoc               v6.33.0
// source: pb_share.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";

export const protobufPackage = "pb_share";

export interface csShareInfoMsg {
}

export interface scShareInfoMsg {
  TotalShareReward: number;
  subCount: number;
  TeamCount: number;
  subCoins: number;
  teamCoins: number;
  totalCoins: number;
  ToBeReceive: number;
  shareUrl: string;
  shareQRCodeUrl: string[];
  clicktitle: string;
  clickurl: string;
}

export interface csShareSubInfoMsg {
  pageSize: number;
  pageIndex: number;
}

export interface subInfoBlock {
  userID: number;
  nick: string;
  userCoins: number;
  teamCoins: number;
  teamCount: number;
  totalCoins: number;
  createTime: number;
}

export interface scShareSubInfoMsg {
  list: subInfoBlock[];
  count: number;
}

export interface csShareReceiveHistory {
}

export interface rewardBlock {
  time: number;
  coin: number;
  nick: string;
}

export interface scShareReceiveHistoryMsg {
  history: rewardBlock[];
}

export interface csShareRankMsg {
}

export interface shareRankBlock {
  nick: string;
  coin: number;
}

export interface scShareRankMsg {
  list: shareRankBlock[];
}

export interface csReceiveRewardMsg {
}

export interface scReceiveRewardMsg {
  status: number;
}

export interface csQuerySubInfoByIdMsg {
  userID: number;
}

export interface scQuerySubInfoByIdMsg {
  info: subInfoBlock | undefined;
}

export interface csGetShareGift {
  index: number;
}

export interface giftItem {
  index: number;
  pcount: number;
  reward: number;
  status: number;
}

export interface scQueryShareGift {
  giftlist: giftItem[];
  subcount: number;
  limit: number;
  betx: number;
}

export interface scGetShareGift {
  gift: giftItem | undefined;
}

function createBasecsShareInfoMsg(): csShareInfoMsg {
  return {};
}

export const csShareInfoMsg: MessageFns<csShareInfoMsg> = {
  encode(_: csShareInfoMsg, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): csShareInfoMsg {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasecsShareInfoMsg();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): csShareInfoMsg {
    return {};
  },

  toJSON(_: csShareInfoMsg): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<csShareInfoMsg>, I>>(base?: I): csShareInfoMsg {
    return csShareInfoMsg.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<csShareInfoMsg>, I>>(_: I): csShareInfoMsg {
    const message = createBasecsShareInfoMsg();
    return message;
  },
};

function createBasescShareInfoMsg(): scShareInfoMsg {
  return {
    TotalShareReward: 0,
    subCount: 0,
    TeamCount: 0,
    subCoins: 0,
    teamCoins: 0,
    totalCoins: 0,
    ToBeReceive: 0,
    shareUrl: "",
    shareQRCodeUrl: [],
    clicktitle: "",
    clickurl: "",
  };
}

export const scShareInfoMsg: MessageFns<scShareInfoMsg> = {
  encode(message: scShareInfoMsg, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.TotalShareReward !== 0) {
      writer.uint32(8).int64(message.TotalShareReward);
    }
    if (message.subCount !== 0) {
      writer.uint32(16).int32(message.subCount);
    }
    if (message.TeamCount !== 0) {
      writer.uint32(24).int32(message.TeamCount);
    }
    if (message.subCoins !== 0) {
      writer.uint32(32).int64(message.subCoins);
    }
    if (message.teamCoins !== 0) {
      writer.uint32(40).int32(message.teamCoins);
    }
    if (message.totalCoins !== 0) {
      writer.uint32(48).int64(message.totalCoins);
    }
    if (message.ToBeReceive !== 0) {
      writer.uint32(56).int64(message.ToBeReceive);
    }
    if (message.shareUrl !== "") {
      writer.uint32(66).string(message.shareUrl);
    }
    for (const v of message.shareQRCodeUrl) {
      writer.uint32(74).string(v!);
    }
    if (message.clicktitle !== "") {
      writer.uint32(82).string(message.clicktitle);
    }
    if (message.clickurl !== "") {
      writer.uint32(90).string(message.clickurl);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): scShareInfoMsg {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasescShareInfoMsg();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.TotalShareReward = longToNumber(reader.int64());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.subCount = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.TeamCount = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.subCoins = longToNumber(reader.int64());
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.teamCoins = reader.int32();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.totalCoins = longToNumber(reader.int64());
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.ToBeReceive = longToNumber(reader.int64());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.shareUrl = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.shareQRCodeUrl.push(reader.string());
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.clicktitle = reader.string();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.clickurl = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): scShareInfoMsg {
    return {
      TotalShareReward: isSet(object.TotalShareReward) ? globalThis.Number(object.TotalShareReward) : 0,
      subCount: isSet(object.subCount) ? globalThis.Number(object.subCount) : 0,
      TeamCount: isSet(object.TeamCount) ? globalThis.Number(object.TeamCount) : 0,
      subCoins: isSet(object.subCoins) ? globalThis.Number(object.subCoins) : 0,
      teamCoins: isSet(object.teamCoins) ? globalThis.Number(object.teamCoins) : 0,
      totalCoins: isSet(object.totalCoins) ? globalThis.Number(object.totalCoins) : 0,
      ToBeReceive: isSet(object.ToBeReceive) ? globalThis.Number(object.ToBeReceive) : 0,
      shareUrl: isSet(object.shareUrl) ? globalThis.String(object.shareUrl) : "",
      shareQRCodeUrl: globalThis.Array.isArray(object?.shareQRCodeUrl)
        ? object.shareQRCodeUrl.map((e: any) => globalThis.String(e))
        : [],
      clicktitle: isSet(object.clicktitle) ? globalThis.String(object.clicktitle) : "",
      clickurl: isSet(object.clickurl) ? globalThis.String(object.clickurl) : "",
    };
  },

  toJSON(message: scShareInfoMsg): unknown {
    const obj: any = {};
    if (message.TotalShareReward !== 0) {
      obj.TotalShareReward = Math.round(message.TotalShareReward);
    }
    if (message.subCount !== 0) {
      obj.subCount = Math.round(message.subCount);
    }
    if (message.TeamCount !== 0) {
      obj.TeamCount = Math.round(message.TeamCount);
    }
    if (message.subCoins !== 0) {
      obj.subCoins = Math.round(message.subCoins);
    }
    if (message.teamCoins !== 0) {
      obj.teamCoins = Math.round(message.teamCoins);
    }
    if (message.totalCoins !== 0) {
      obj.totalCoins = Math.round(message.totalCoins);
    }
    if (message.ToBeReceive !== 0) {
      obj.ToBeReceive = Math.round(message.ToBeReceive);
    }
    if (message.shareUrl !== "") {
      obj.shareUrl = message.shareUrl;
    }
    if (message.shareQRCodeUrl?.length) {
      obj.shareQRCodeUrl = message.shareQRCodeUrl;
    }
    if (message.clicktitle !== "") {
      obj.clicktitle = message.clicktitle;
    }
    if (message.clickurl !== "") {
      obj.clickurl = message.clickurl;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<scShareInfoMsg>, I>>(base?: I): scShareInfoMsg {
    return scShareInfoMsg.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<scShareInfoMsg>, I>>(object: I): scShareInfoMsg {
    const message = createBasescShareInfoMsg();
    message.TotalShareReward = object.TotalShareReward ?? 0;
    message.subCount = object.subCount ?? 0;
    message.TeamCount = object.TeamCount ?? 0;
    message.subCoins = object.subCoins ?? 0;
    message.teamCoins = object.teamCoins ?? 0;
    message.totalCoins = object.totalCoins ?? 0;
    message.ToBeReceive = object.ToBeReceive ?? 0;
    message.shareUrl = object.shareUrl ?? "";
    message.shareQRCodeUrl = object.shareQRCodeUrl?.map((e) => e) || [];
    message.clicktitle = object.clicktitle ?? "";
    message.clickurl = object.clickurl ?? "";
    return message;
  },
};

function createBasecsShareSubInfoMsg(): csShareSubInfoMsg {
  return { pageSize: 0, pageIndex: 0 };
}

export const csShareSubInfoMsg: MessageFns<csShareSubInfoMsg> = {
  encode(message: csShareSubInfoMsg, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.pageSize !== 0) {
      writer.uint32(8).int32(message.pageSize);
    }
    if (message.pageIndex !== 0) {
      writer.uint32(16).int32(message.pageIndex);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): csShareSubInfoMsg {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasecsShareSubInfoMsg();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.pageIndex = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): csShareSubInfoMsg {
    return {
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageIndex: isSet(object.pageIndex) ? globalThis.Number(object.pageIndex) : 0,
    };
  },

  toJSON(message: csShareSubInfoMsg): unknown {
    const obj: any = {};
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageIndex !== 0) {
      obj.pageIndex = Math.round(message.pageIndex);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<csShareSubInfoMsg>, I>>(base?: I): csShareSubInfoMsg {
    return csShareSubInfoMsg.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<csShareSubInfoMsg>, I>>(object: I): csShareSubInfoMsg {
    const message = createBasecsShareSubInfoMsg();
    message.pageSize = object.pageSize ?? 0;
    message.pageIndex = object.pageIndex ?? 0;
    return message;
  },
};

function createBasesubInfoBlock(): subInfoBlock {
  return { userID: 0, nick: "", userCoins: 0, teamCoins: 0, teamCount: 0, totalCoins: 0, createTime: 0 };
}

export const subInfoBlock: MessageFns<subInfoBlock> = {
  encode(message: subInfoBlock, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userID !== 0) {
      writer.uint32(8).int32(message.userID);
    }
    if (message.nick !== "") {
      writer.uint32(18).string(message.nick);
    }
    if (message.userCoins !== 0) {
      writer.uint32(24).int64(message.userCoins);
    }
    if (message.teamCoins !== 0) {
      writer.uint32(32).int64(message.teamCoins);
    }
    if (message.teamCount !== 0) {
      writer.uint32(40).int32(message.teamCount);
    }
    if (message.totalCoins !== 0) {
      writer.uint32(48).int64(message.totalCoins);
    }
    if (message.createTime !== 0) {
      writer.uint32(56).int64(message.createTime);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): subInfoBlock {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasesubInfoBlock();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.userID = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.nick = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.userCoins = longToNumber(reader.int64());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.teamCoins = longToNumber(reader.int64());
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.teamCount = reader.int32();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.totalCoins = longToNumber(reader.int64());
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.createTime = longToNumber(reader.int64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): subInfoBlock {
    return {
      userID: isSet(object.userID) ? globalThis.Number(object.userID) : 0,
      nick: isSet(object.nick) ? globalThis.String(object.nick) : "",
      userCoins: isSet(object.userCoins) ? globalThis.Number(object.userCoins) : 0,
      teamCoins: isSet(object.teamCoins) ? globalThis.Number(object.teamCoins) : 0,
      teamCount: isSet(object.teamCount) ? globalThis.Number(object.teamCount) : 0,
      totalCoins: isSet(object.totalCoins) ? globalThis.Number(object.totalCoins) : 0,
      createTime: isSet(object.createTime) ? globalThis.Number(object.createTime) : 0,
    };
  },

  toJSON(message: subInfoBlock): unknown {
    const obj: any = {};
    if (message.userID !== 0) {
      obj.userID = Math.round(message.userID);
    }
    if (message.nick !== "") {
      obj.nick = message.nick;
    }
    if (message.userCoins !== 0) {
      obj.userCoins = Math.round(message.userCoins);
    }
    if (message.teamCoins !== 0) {
      obj.teamCoins = Math.round(message.teamCoins);
    }
    if (message.teamCount !== 0) {
      obj.teamCount = Math.round(message.teamCount);
    }
    if (message.totalCoins !== 0) {
      obj.totalCoins = Math.round(message.totalCoins);
    }
    if (message.createTime !== 0) {
      obj.createTime = Math.round(message.createTime);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<subInfoBlock>, I>>(base?: I): subInfoBlock {
    return subInfoBlock.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<subInfoBlock>, I>>(object: I): subInfoBlock {
    const message = createBasesubInfoBlock();
    message.userID = object.userID ?? 0;
    message.nick = object.nick ?? "";
    message.userCoins = object.userCoins ?? 0;
    message.teamCoins = object.teamCoins ?? 0;
    message.teamCount = object.teamCount ?? 0;
    message.totalCoins = object.totalCoins ?? 0;
    message.createTime = object.createTime ?? 0;
    return message;
  },
};

function createBasescShareSubInfoMsg(): scShareSubInfoMsg {
  return { list: [], count: 0 };
}

export const scShareSubInfoMsg: MessageFns<scShareSubInfoMsg> = {
  encode(message: scShareSubInfoMsg, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.list) {
      subInfoBlock.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.count !== 0) {
      writer.uint32(16).int32(message.count);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): scShareSubInfoMsg {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasescShareSubInfoMsg();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.list.push(subInfoBlock.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.count = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): scShareSubInfoMsg {
    return {
      list: globalThis.Array.isArray(object?.list) ? object.list.map((e: any) => subInfoBlock.fromJSON(e)) : [],
      count: isSet(object.count) ? globalThis.Number(object.count) : 0,
    };
  },

  toJSON(message: scShareSubInfoMsg): unknown {
    const obj: any = {};
    if (message.list?.length) {
      obj.list = message.list.map((e) => subInfoBlock.toJSON(e));
    }
    if (message.count !== 0) {
      obj.count = Math.round(message.count);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<scShareSubInfoMsg>, I>>(base?: I): scShareSubInfoMsg {
    return scShareSubInfoMsg.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<scShareSubInfoMsg>, I>>(object: I): scShareSubInfoMsg {
    const message = createBasescShareSubInfoMsg();
    message.list = object.list?.map((e) => subInfoBlock.fromPartial(e)) || [];
    message.count = object.count ?? 0;
    return message;
  },
};

function createBasecsShareReceiveHistory(): csShareReceiveHistory {
  return {};
}

export const csShareReceiveHistory: MessageFns<csShareReceiveHistory> = {
  encode(_: csShareReceiveHistory, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): csShareReceiveHistory {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasecsShareReceiveHistory();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): csShareReceiveHistory {
    return {};
  },

  toJSON(_: csShareReceiveHistory): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<csShareReceiveHistory>, I>>(base?: I): csShareReceiveHistory {
    return csShareReceiveHistory.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<csShareReceiveHistory>, I>>(_: I): csShareReceiveHistory {
    const message = createBasecsShareReceiveHistory();
    return message;
  },
};

function createBaserewardBlock(): rewardBlock {
  return { time: 0, coin: 0, nick: "" };
}

export const rewardBlock: MessageFns<rewardBlock> = {
  encode(message: rewardBlock, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.time !== 0) {
      writer.uint32(8).int64(message.time);
    }
    if (message.coin !== 0) {
      writer.uint32(16).int64(message.coin);
    }
    if (message.nick !== "") {
      writer.uint32(26).string(message.nick);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): rewardBlock {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaserewardBlock();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.time = longToNumber(reader.int64());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.coin = longToNumber(reader.int64());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.nick = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): rewardBlock {
    return {
      time: isSet(object.time) ? globalThis.Number(object.time) : 0,
      coin: isSet(object.coin) ? globalThis.Number(object.coin) : 0,
      nick: isSet(object.nick) ? globalThis.String(object.nick) : "",
    };
  },

  toJSON(message: rewardBlock): unknown {
    const obj: any = {};
    if (message.time !== 0) {
      obj.time = Math.round(message.time);
    }
    if (message.coin !== 0) {
      obj.coin = Math.round(message.coin);
    }
    if (message.nick !== "") {
      obj.nick = message.nick;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<rewardBlock>, I>>(base?: I): rewardBlock {
    return rewardBlock.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<rewardBlock>, I>>(object: I): rewardBlock {
    const message = createBaserewardBlock();
    message.time = object.time ?? 0;
    message.coin = object.coin ?? 0;
    message.nick = object.nick ?? "";
    return message;
  },
};

function createBasescShareReceiveHistoryMsg(): scShareReceiveHistoryMsg {
  return { history: [] };
}

export const scShareReceiveHistoryMsg: MessageFns<scShareReceiveHistoryMsg> = {
  encode(message: scShareReceiveHistoryMsg, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.history) {
      rewardBlock.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): scShareReceiveHistoryMsg {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasescShareReceiveHistoryMsg();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.history.push(rewardBlock.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): scShareReceiveHistoryMsg {
    return {
      history: globalThis.Array.isArray(object?.history) ? object.history.map((e: any) => rewardBlock.fromJSON(e)) : [],
    };
  },

  toJSON(message: scShareReceiveHistoryMsg): unknown {
    const obj: any = {};
    if (message.history?.length) {
      obj.history = message.history.map((e) => rewardBlock.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<scShareReceiveHistoryMsg>, I>>(base?: I): scShareReceiveHistoryMsg {
    return scShareReceiveHistoryMsg.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<scShareReceiveHistoryMsg>, I>>(object: I): scShareReceiveHistoryMsg {
    const message = createBasescShareReceiveHistoryMsg();
    message.history = object.history?.map((e) => rewardBlock.fromPartial(e)) || [];
    return message;
  },
};

function createBasecsShareRankMsg(): csShareRankMsg {
  return {};
}

export const csShareRankMsg: MessageFns<csShareRankMsg> = {
  encode(_: csShareRankMsg, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): csShareRankMsg {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasecsShareRankMsg();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): csShareRankMsg {
    return {};
  },

  toJSON(_: csShareRankMsg): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<csShareRankMsg>, I>>(base?: I): csShareRankMsg {
    return csShareRankMsg.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<csShareRankMsg>, I>>(_: I): csShareRankMsg {
    const message = createBasecsShareRankMsg();
    return message;
  },
};

function createBaseshareRankBlock(): shareRankBlock {
  return { nick: "", coin: 0 };
}

export const shareRankBlock: MessageFns<shareRankBlock> = {
  encode(message: shareRankBlock, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.nick !== "") {
      writer.uint32(10).string(message.nick);
    }
    if (message.coin !== 0) {
      writer.uint32(16).int64(message.coin);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): shareRankBlock {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseshareRankBlock();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.nick = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.coin = longToNumber(reader.int64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): shareRankBlock {
    return {
      nick: isSet(object.nick) ? globalThis.String(object.nick) : "",
      coin: isSet(object.coin) ? globalThis.Number(object.coin) : 0,
    };
  },

  toJSON(message: shareRankBlock): unknown {
    const obj: any = {};
    if (message.nick !== "") {
      obj.nick = message.nick;
    }
    if (message.coin !== 0) {
      obj.coin = Math.round(message.coin);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<shareRankBlock>, I>>(base?: I): shareRankBlock {
    return shareRankBlock.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<shareRankBlock>, I>>(object: I): shareRankBlock {
    const message = createBaseshareRankBlock();
    message.nick = object.nick ?? "";
    message.coin = object.coin ?? 0;
    return message;
  },
};

function createBasescShareRankMsg(): scShareRankMsg {
  return { list: [] };
}

export const scShareRankMsg: MessageFns<scShareRankMsg> = {
  encode(message: scShareRankMsg, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.list) {
      shareRankBlock.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): scShareRankMsg {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasescShareRankMsg();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.list.push(shareRankBlock.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): scShareRankMsg {
    return {
      list: globalThis.Array.isArray(object?.list) ? object.list.map((e: any) => shareRankBlock.fromJSON(e)) : [],
    };
  },

  toJSON(message: scShareRankMsg): unknown {
    const obj: any = {};
    if (message.list?.length) {
      obj.list = message.list.map((e) => shareRankBlock.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<scShareRankMsg>, I>>(base?: I): scShareRankMsg {
    return scShareRankMsg.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<scShareRankMsg>, I>>(object: I): scShareRankMsg {
    const message = createBasescShareRankMsg();
    message.list = object.list?.map((e) => shareRankBlock.fromPartial(e)) || [];
    return message;
  },
};

function createBasecsReceiveRewardMsg(): csReceiveRewardMsg {
  return {};
}

export const csReceiveRewardMsg: MessageFns<csReceiveRewardMsg> = {
  encode(_: csReceiveRewardMsg, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): csReceiveRewardMsg {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasecsReceiveRewardMsg();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): csReceiveRewardMsg {
    return {};
  },

  toJSON(_: csReceiveRewardMsg): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<csReceiveRewardMsg>, I>>(base?: I): csReceiveRewardMsg {
    return csReceiveRewardMsg.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<csReceiveRewardMsg>, I>>(_: I): csReceiveRewardMsg {
    const message = createBasecsReceiveRewardMsg();
    return message;
  },
};

function createBasescReceiveRewardMsg(): scReceiveRewardMsg {
  return { status: 0 };
}

export const scReceiveRewardMsg: MessageFns<scReceiveRewardMsg> = {
  encode(message: scReceiveRewardMsg, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== 0) {
      writer.uint32(8).int32(message.status);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): scReceiveRewardMsg {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasescReceiveRewardMsg();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.status = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): scReceiveRewardMsg {
    return { status: isSet(object.status) ? globalThis.Number(object.status) : 0 };
  },

  toJSON(message: scReceiveRewardMsg): unknown {
    const obj: any = {};
    if (message.status !== 0) {
      obj.status = Math.round(message.status);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<scReceiveRewardMsg>, I>>(base?: I): scReceiveRewardMsg {
    return scReceiveRewardMsg.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<scReceiveRewardMsg>, I>>(object: I): scReceiveRewardMsg {
    const message = createBasescReceiveRewardMsg();
    message.status = object.status ?? 0;
    return message;
  },
};

function createBasecsQuerySubInfoByIdMsg(): csQuerySubInfoByIdMsg {
  return { userID: 0 };
}

export const csQuerySubInfoByIdMsg: MessageFns<csQuerySubInfoByIdMsg> = {
  encode(message: csQuerySubInfoByIdMsg, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userID !== 0) {
      writer.uint32(8).int32(message.userID);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): csQuerySubInfoByIdMsg {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasecsQuerySubInfoByIdMsg();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.userID = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): csQuerySubInfoByIdMsg {
    return { userID: isSet(object.userID) ? globalThis.Number(object.userID) : 0 };
  },

  toJSON(message: csQuerySubInfoByIdMsg): unknown {
    const obj: any = {};
    if (message.userID !== 0) {
      obj.userID = Math.round(message.userID);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<csQuerySubInfoByIdMsg>, I>>(base?: I): csQuerySubInfoByIdMsg {
    return csQuerySubInfoByIdMsg.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<csQuerySubInfoByIdMsg>, I>>(object: I): csQuerySubInfoByIdMsg {
    const message = createBasecsQuerySubInfoByIdMsg();
    message.userID = object.userID ?? 0;
    return message;
  },
};

function createBasescQuerySubInfoByIdMsg(): scQuerySubInfoByIdMsg {
  return { info: undefined };
}

export const scQuerySubInfoByIdMsg: MessageFns<scQuerySubInfoByIdMsg> = {
  encode(message: scQuerySubInfoByIdMsg, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.info !== undefined) {
      subInfoBlock.encode(message.info, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): scQuerySubInfoByIdMsg {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasescQuerySubInfoByIdMsg();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.info = subInfoBlock.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): scQuerySubInfoByIdMsg {
    return { info: isSet(object.info) ? subInfoBlock.fromJSON(object.info) : undefined };
  },

  toJSON(message: scQuerySubInfoByIdMsg): unknown {
    const obj: any = {};
    if (message.info !== undefined) {
      obj.info = subInfoBlock.toJSON(message.info);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<scQuerySubInfoByIdMsg>, I>>(base?: I): scQuerySubInfoByIdMsg {
    return scQuerySubInfoByIdMsg.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<scQuerySubInfoByIdMsg>, I>>(object: I): scQuerySubInfoByIdMsg {
    const message = createBasescQuerySubInfoByIdMsg();
    message.info = (object.info !== undefined && object.info !== null)
      ? subInfoBlock.fromPartial(object.info)
      : undefined;
    return message;
  },
};

function createBasecsGetShareGift(): csGetShareGift {
  return { index: 0 };
}

export const csGetShareGift: MessageFns<csGetShareGift> = {
  encode(message: csGetShareGift, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.index !== 0) {
      writer.uint32(8).int32(message.index);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): csGetShareGift {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasecsGetShareGift();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.index = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): csGetShareGift {
    return { index: isSet(object.index) ? globalThis.Number(object.index) : 0 };
  },

  toJSON(message: csGetShareGift): unknown {
    const obj: any = {};
    if (message.index !== 0) {
      obj.index = Math.round(message.index);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<csGetShareGift>, I>>(base?: I): csGetShareGift {
    return csGetShareGift.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<csGetShareGift>, I>>(object: I): csGetShareGift {
    const message = createBasecsGetShareGift();
    message.index = object.index ?? 0;
    return message;
  },
};

function createBasegiftItem(): giftItem {
  return { index: 0, pcount: 0, reward: 0, status: 0 };
}

export const giftItem: MessageFns<giftItem> = {
  encode(message: giftItem, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.index !== 0) {
      writer.uint32(8).int32(message.index);
    }
    if (message.pcount !== 0) {
      writer.uint32(16).int32(message.pcount);
    }
    if (message.reward !== 0) {
      writer.uint32(24).int64(message.reward);
    }
    if (message.status !== 0) {
      writer.uint32(32).int32(message.status);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): giftItem {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasegiftItem();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.index = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.pcount = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.reward = longToNumber(reader.int64());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.status = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): giftItem {
    return {
      index: isSet(object.index) ? globalThis.Number(object.index) : 0,
      pcount: isSet(object.pcount) ? globalThis.Number(object.pcount) : 0,
      reward: isSet(object.reward) ? globalThis.Number(object.reward) : 0,
      status: isSet(object.status) ? globalThis.Number(object.status) : 0,
    };
  },

  toJSON(message: giftItem): unknown {
    const obj: any = {};
    if (message.index !== 0) {
      obj.index = Math.round(message.index);
    }
    if (message.pcount !== 0) {
      obj.pcount = Math.round(message.pcount);
    }
    if (message.reward !== 0) {
      obj.reward = Math.round(message.reward);
    }
    if (message.status !== 0) {
      obj.status = Math.round(message.status);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<giftItem>, I>>(base?: I): giftItem {
    return giftItem.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<giftItem>, I>>(object: I): giftItem {
    const message = createBasegiftItem();
    message.index = object.index ?? 0;
    message.pcount = object.pcount ?? 0;
    message.reward = object.reward ?? 0;
    message.status = object.status ?? 0;
    return message;
  },
};

function createBasescQueryShareGift(): scQueryShareGift {
  return { giftlist: [], subcount: 0, limit: 0, betx: 0 };
}

export const scQueryShareGift: MessageFns<scQueryShareGift> = {
  encode(message: scQueryShareGift, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.giftlist) {
      giftItem.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.subcount !== 0) {
      writer.uint32(16).int64(message.subcount);
    }
    if (message.limit !== 0) {
      writer.uint32(24).int64(message.limit);
    }
    if (message.betx !== 0) {
      writer.uint32(32).int32(message.betx);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): scQueryShareGift {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasescQueryShareGift();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.giftlist.push(giftItem.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.subcount = longToNumber(reader.int64());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.limit = longToNumber(reader.int64());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.betx = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): scQueryShareGift {
    return {
      giftlist: globalThis.Array.isArray(object?.giftlist) ? object.giftlist.map((e: any) => giftItem.fromJSON(e)) : [],
      subcount: isSet(object.subcount) ? globalThis.Number(object.subcount) : 0,
      limit: isSet(object.limit) ? globalThis.Number(object.limit) : 0,
      betx: isSet(object.betx) ? globalThis.Number(object.betx) : 0,
    };
  },

  toJSON(message: scQueryShareGift): unknown {
    const obj: any = {};
    if (message.giftlist?.length) {
      obj.giftlist = message.giftlist.map((e) => giftItem.toJSON(e));
    }
    if (message.subcount !== 0) {
      obj.subcount = Math.round(message.subcount);
    }
    if (message.limit !== 0) {
      obj.limit = Math.round(message.limit);
    }
    if (message.betx !== 0) {
      obj.betx = Math.round(message.betx);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<scQueryShareGift>, I>>(base?: I): scQueryShareGift {
    return scQueryShareGift.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<scQueryShareGift>, I>>(object: I): scQueryShareGift {
    const message = createBasescQueryShareGift();
    message.giftlist = object.giftlist?.map((e) => giftItem.fromPartial(e)) || [];
    message.subcount = object.subcount ?? 0;
    message.limit = object.limit ?? 0;
    message.betx = object.betx ?? 0;
    return message;
  },
};

function createBasescGetShareGift(): scGetShareGift {
  return { gift: undefined };
}

export const scGetShareGift: MessageFns<scGetShareGift> = {
  encode(message: scGetShareGift, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.gift !== undefined) {
      giftItem.encode(message.gift, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): scGetShareGift {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasescGetShareGift();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.gift = giftItem.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): scGetShareGift {
    return { gift: isSet(object.gift) ? giftItem.fromJSON(object.gift) : undefined };
  },

  toJSON(message: scGetShareGift): unknown {
    const obj: any = {};
    if (message.gift !== undefined) {
      obj.gift = giftItem.toJSON(message.gift);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<scGetShareGift>, I>>(base?: I): scGetShareGift {
    return scGetShareGift.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<scGetShareGift>, I>>(object: I): scGetShareGift {
    const message = createBasescGetShareGift();
    message.gift = (object.gift !== undefined && object.gift !== null) ? giftItem.fromPartial(object.gift) : undefined;
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function longToNumber(int64: { toString(): string }): number {
  const num = globalThis.Number(int64.toString());
  if (num > globalThis.Number.MAX_SAFE_INTEGER) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (num < globalThis.Number.MIN_SAFE_INTEGER) {
    throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return num;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
