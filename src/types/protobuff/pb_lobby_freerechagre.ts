// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.8.3
//   protoc               v6.33.0
// source: pb_lobby_freerechagre.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";

export const protobufPackage = "pb_lobby_freerechagre";

/** ====== config_data ====== */
export interface configData {
  /** valor mínimo */
  min: number;
  /** valor máximo */
  max: number;
  /** contagem */
  counts: number;
}

/** ====== sc_data_from_config ====== */
export interface scDataFromConfig {
  targetmoney: number;
  beginmoneymax: number;
  beginmoneymix: number;
  days: number;
  InvitationPepole: number;
  FinshTaskDays: number;
  FinshTaskCount: number;
  configdata: configData[];
}

/** ====== sc_showbefore_msg ====== */
export interface scShowbeforeMsg {
  status: number;
  complatemoney: number;
}

/** ====== sc_freerechagre_get ====== */
export interface scFreerechagreGet {
  money: number;
}

/** ====== all_recode_data ====== */
export interface allRecodeData {
  name: string;
  money: number;
}

/** ====== sc_getfree_msg ====== */
export interface scGetfreeMsg {
  endtime: number;
  recodedata: allRecodeData[];
  freecounts: number;
  complatemoney: number;
  mymoney: number;
  sharedurl: string;
  bsharephone: boolean;
  betx: number;
}

/** ====== sc_rota_msg ====== */
export interface scRotaMsg {
  money: number;
}

/** ====== cs_my_recode_msg ====== */
export interface csMyRecodeMsg {
  page: number;
  count: number;
}

/** ====== my_recode_data ====== */
export interface myRecodeData {
  name: string;
  money: number;
}

/** ====== sc_my_recode_msg ====== */
export interface scMyRecodeMsg {
  data: myRecodeData[];
}

/** ====== sc_get_all_money_msg ====== */
export interface scGetAllMoneyMsg {
  money: number;
}

/** ====== sc_new_help_msg ====== */
export interface scNewHelpMsg {
  name: string;
  counts: number;
}

function createBaseconfigData(): configData {
  return { min: 0, max: 0, counts: 0 };
}

export const configData: MessageFns<configData> = {
  encode(message: configData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.min !== 0) {
      writer.uint32(24).int64(message.min);
    }
    if (message.max !== 0) {
      writer.uint32(32).int64(message.max);
    }
    if (message.counts !== 0) {
      writer.uint32(40).int32(message.counts);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): configData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseconfigData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.min = longToNumber(reader.int64());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.max = longToNumber(reader.int64());
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.counts = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): configData {
    return {
      min: isSet(object.min) ? globalThis.Number(object.min) : 0,
      max: isSet(object.max) ? globalThis.Number(object.max) : 0,
      counts: isSet(object.counts) ? globalThis.Number(object.counts) : 0,
    };
  },

  toJSON(message: configData): unknown {
    const obj: any = {};
    if (message.min !== 0) {
      obj.min = Math.round(message.min);
    }
    if (message.max !== 0) {
      obj.max = Math.round(message.max);
    }
    if (message.counts !== 0) {
      obj.counts = Math.round(message.counts);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<configData>, I>>(base?: I): configData {
    return configData.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<configData>, I>>(object: I): configData {
    const message = createBaseconfigData();
    message.min = object.min ?? 0;
    message.max = object.max ?? 0;
    message.counts = object.counts ?? 0;
    return message;
  },
};

function createBasescDataFromConfig(): scDataFromConfig {
  return {
    targetmoney: 0,
    beginmoneymax: 0,
    beginmoneymix: 0,
    days: 0,
    InvitationPepole: 0,
    FinshTaskDays: 0,
    FinshTaskCount: 0,
    configdata: [],
  };
}

export const scDataFromConfig: MessageFns<scDataFromConfig> = {
  encode(message: scDataFromConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.targetmoney !== 0) {
      writer.uint32(8).int32(message.targetmoney);
    }
    if (message.beginmoneymax !== 0) {
      writer.uint32(16).int32(message.beginmoneymax);
    }
    if (message.beginmoneymix !== 0) {
      writer.uint32(24).int32(message.beginmoneymix);
    }
    if (message.days !== 0) {
      writer.uint32(32).int32(message.days);
    }
    if (message.InvitationPepole !== 0) {
      writer.uint32(40).int32(message.InvitationPepole);
    }
    if (message.FinshTaskDays !== 0) {
      writer.uint32(48).int32(message.FinshTaskDays);
    }
    if (message.FinshTaskCount !== 0) {
      writer.uint32(56).int32(message.FinshTaskCount);
    }
    for (const v of message.configdata) {
      configData.encode(v!, writer.uint32(66).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): scDataFromConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasescDataFromConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.targetmoney = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.beginmoneymax = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.beginmoneymix = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.days = reader.int32();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.InvitationPepole = reader.int32();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.FinshTaskDays = reader.int32();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.FinshTaskCount = reader.int32();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.configdata.push(configData.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): scDataFromConfig {
    return {
      targetmoney: isSet(object.targetmoney) ? globalThis.Number(object.targetmoney) : 0,
      beginmoneymax: isSet(object.beginmoneymax) ? globalThis.Number(object.beginmoneymax) : 0,
      beginmoneymix: isSet(object.beginmoneymix) ? globalThis.Number(object.beginmoneymix) : 0,
      days: isSet(object.days) ? globalThis.Number(object.days) : 0,
      InvitationPepole: isSet(object.InvitationPepole) ? globalThis.Number(object.InvitationPepole) : 0,
      FinshTaskDays: isSet(object.FinshTaskDays) ? globalThis.Number(object.FinshTaskDays) : 0,
      FinshTaskCount: isSet(object.FinshTaskCount) ? globalThis.Number(object.FinshTaskCount) : 0,
      configdata: globalThis.Array.isArray(object?.configdata)
        ? object.configdata.map((e: any) => configData.fromJSON(e))
        : [],
    };
  },

  toJSON(message: scDataFromConfig): unknown {
    const obj: any = {};
    if (message.targetmoney !== 0) {
      obj.targetmoney = Math.round(message.targetmoney);
    }
    if (message.beginmoneymax !== 0) {
      obj.beginmoneymax = Math.round(message.beginmoneymax);
    }
    if (message.beginmoneymix !== 0) {
      obj.beginmoneymix = Math.round(message.beginmoneymix);
    }
    if (message.days !== 0) {
      obj.days = Math.round(message.days);
    }
    if (message.InvitationPepole !== 0) {
      obj.InvitationPepole = Math.round(message.InvitationPepole);
    }
    if (message.FinshTaskDays !== 0) {
      obj.FinshTaskDays = Math.round(message.FinshTaskDays);
    }
    if (message.FinshTaskCount !== 0) {
      obj.FinshTaskCount = Math.round(message.FinshTaskCount);
    }
    if (message.configdata?.length) {
      obj.configdata = message.configdata.map((e) => configData.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<scDataFromConfig>, I>>(base?: I): scDataFromConfig {
    return scDataFromConfig.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<scDataFromConfig>, I>>(object: I): scDataFromConfig {
    const message = createBasescDataFromConfig();
    message.targetmoney = object.targetmoney ?? 0;
    message.beginmoneymax = object.beginmoneymax ?? 0;
    message.beginmoneymix = object.beginmoneymix ?? 0;
    message.days = object.days ?? 0;
    message.InvitationPepole = object.InvitationPepole ?? 0;
    message.FinshTaskDays = object.FinshTaskDays ?? 0;
    message.FinshTaskCount = object.FinshTaskCount ?? 0;
    message.configdata = object.configdata?.map((e) => configData.fromPartial(e)) || [];
    return message;
  },
};

function createBasescShowbeforeMsg(): scShowbeforeMsg {
  return { status: 0, complatemoney: 0 };
}

export const scShowbeforeMsg: MessageFns<scShowbeforeMsg> = {
  encode(message: scShowbeforeMsg, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== 0) {
      writer.uint32(8).int32(message.status);
    }
    if (message.complatemoney !== 0) {
      writer.uint32(32).int64(message.complatemoney);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): scShowbeforeMsg {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasescShowbeforeMsg();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.status = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.complatemoney = longToNumber(reader.int64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): scShowbeforeMsg {
    return {
      status: isSet(object.status) ? globalThis.Number(object.status) : 0,
      complatemoney: isSet(object.complatemoney) ? globalThis.Number(object.complatemoney) : 0,
    };
  },

  toJSON(message: scShowbeforeMsg): unknown {
    const obj: any = {};
    if (message.status !== 0) {
      obj.status = Math.round(message.status);
    }
    if (message.complatemoney !== 0) {
      obj.complatemoney = Math.round(message.complatemoney);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<scShowbeforeMsg>, I>>(base?: I): scShowbeforeMsg {
    return scShowbeforeMsg.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<scShowbeforeMsg>, I>>(object: I): scShowbeforeMsg {
    const message = createBasescShowbeforeMsg();
    message.status = object.status ?? 0;
    message.complatemoney = object.complatemoney ?? 0;
    return message;
  },
};

function createBasescFreerechagreGet(): scFreerechagreGet {
  return { money: 0 };
}

export const scFreerechagreGet: MessageFns<scFreerechagreGet> = {
  encode(message: scFreerechagreGet, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.money !== 0) {
      writer.uint32(8).int64(message.money);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): scFreerechagreGet {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasescFreerechagreGet();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.money = longToNumber(reader.int64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): scFreerechagreGet {
    return { money: isSet(object.money) ? globalThis.Number(object.money) : 0 };
  },

  toJSON(message: scFreerechagreGet): unknown {
    const obj: any = {};
    if (message.money !== 0) {
      obj.money = Math.round(message.money);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<scFreerechagreGet>, I>>(base?: I): scFreerechagreGet {
    return scFreerechagreGet.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<scFreerechagreGet>, I>>(object: I): scFreerechagreGet {
    const message = createBasescFreerechagreGet();
    message.money = object.money ?? 0;
    return message;
  },
};

function createBaseallRecodeData(): allRecodeData {
  return { name: "", money: 0 };
}

export const allRecodeData: MessageFns<allRecodeData> = {
  encode(message: allRecodeData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.money !== 0) {
      writer.uint32(16).int64(message.money);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): allRecodeData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseallRecodeData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.money = longToNumber(reader.int64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): allRecodeData {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      money: isSet(object.money) ? globalThis.Number(object.money) : 0,
    };
  },

  toJSON(message: allRecodeData): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.money !== 0) {
      obj.money = Math.round(message.money);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<allRecodeData>, I>>(base?: I): allRecodeData {
    return allRecodeData.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<allRecodeData>, I>>(object: I): allRecodeData {
    const message = createBaseallRecodeData();
    message.name = object.name ?? "";
    message.money = object.money ?? 0;
    return message;
  },
};

function createBasescGetfreeMsg(): scGetfreeMsg {
  return {
    endtime: 0,
    recodedata: [],
    freecounts: 0,
    complatemoney: 0,
    mymoney: 0,
    sharedurl: "",
    bsharephone: false,
    betx: 0,
  };
}

export const scGetfreeMsg: MessageFns<scGetfreeMsg> = {
  encode(message: scGetfreeMsg, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.endtime !== 0) {
      writer.uint32(8).int64(message.endtime);
    }
    for (const v of message.recodedata) {
      allRecodeData.encode(v!, writer.uint32(18).fork()).join();
    }
    if (message.freecounts !== 0) {
      writer.uint32(24).int32(message.freecounts);
    }
    if (message.complatemoney !== 0) {
      writer.uint32(32).int64(message.complatemoney);
    }
    if (message.mymoney !== 0) {
      writer.uint32(40).int64(message.mymoney);
    }
    if (message.sharedurl !== "") {
      writer.uint32(50).string(message.sharedurl);
    }
    if (message.bsharephone !== false) {
      writer.uint32(56).bool(message.bsharephone);
    }
    if (message.betx !== 0) {
      writer.uint32(64).int32(message.betx);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): scGetfreeMsg {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasescGetfreeMsg();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.endtime = longToNumber(reader.int64());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.recodedata.push(allRecodeData.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.freecounts = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.complatemoney = longToNumber(reader.int64());
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.mymoney = longToNumber(reader.int64());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.sharedurl = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.bsharephone = reader.bool();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.betx = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): scGetfreeMsg {
    return {
      endtime: isSet(object.endtime) ? globalThis.Number(object.endtime) : 0,
      recodedata: globalThis.Array.isArray(object?.recodedata)
        ? object.recodedata.map((e: any) => allRecodeData.fromJSON(e))
        : [],
      freecounts: isSet(object.freecounts) ? globalThis.Number(object.freecounts) : 0,
      complatemoney: isSet(object.complatemoney) ? globalThis.Number(object.complatemoney) : 0,
      mymoney: isSet(object.mymoney) ? globalThis.Number(object.mymoney) : 0,
      sharedurl: isSet(object.sharedurl) ? globalThis.String(object.sharedurl) : "",
      bsharephone: isSet(object.bsharephone) ? globalThis.Boolean(object.bsharephone) : false,
      betx: isSet(object.betx) ? globalThis.Number(object.betx) : 0,
    };
  },

  toJSON(message: scGetfreeMsg): unknown {
    const obj: any = {};
    if (message.endtime !== 0) {
      obj.endtime = Math.round(message.endtime);
    }
    if (message.recodedata?.length) {
      obj.recodedata = message.recodedata.map((e) => allRecodeData.toJSON(e));
    }
    if (message.freecounts !== 0) {
      obj.freecounts = Math.round(message.freecounts);
    }
    if (message.complatemoney !== 0) {
      obj.complatemoney = Math.round(message.complatemoney);
    }
    if (message.mymoney !== 0) {
      obj.mymoney = Math.round(message.mymoney);
    }
    if (message.sharedurl !== "") {
      obj.sharedurl = message.sharedurl;
    }
    if (message.bsharephone !== false) {
      obj.bsharephone = message.bsharephone;
    }
    if (message.betx !== 0) {
      obj.betx = Math.round(message.betx);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<scGetfreeMsg>, I>>(base?: I): scGetfreeMsg {
    return scGetfreeMsg.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<scGetfreeMsg>, I>>(object: I): scGetfreeMsg {
    const message = createBasescGetfreeMsg();
    message.endtime = object.endtime ?? 0;
    message.recodedata = object.recodedata?.map((e) => allRecodeData.fromPartial(e)) || [];
    message.freecounts = object.freecounts ?? 0;
    message.complatemoney = object.complatemoney ?? 0;
    message.mymoney = object.mymoney ?? 0;
    message.sharedurl = object.sharedurl ?? "";
    message.bsharephone = object.bsharephone ?? false;
    message.betx = object.betx ?? 0;
    return message;
  },
};

function createBasescRotaMsg(): scRotaMsg {
  return { money: 0 };
}

export const scRotaMsg: MessageFns<scRotaMsg> = {
  encode(message: scRotaMsg, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.money !== 0) {
      writer.uint32(8).int64(message.money);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): scRotaMsg {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasescRotaMsg();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.money = longToNumber(reader.int64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): scRotaMsg {
    return { money: isSet(object.money) ? globalThis.Number(object.money) : 0 };
  },

  toJSON(message: scRotaMsg): unknown {
    const obj: any = {};
    if (message.money !== 0) {
      obj.money = Math.round(message.money);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<scRotaMsg>, I>>(base?: I): scRotaMsg {
    return scRotaMsg.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<scRotaMsg>, I>>(object: I): scRotaMsg {
    const message = createBasescRotaMsg();
    message.money = object.money ?? 0;
    return message;
  },
};

function createBasecsMyRecodeMsg(): csMyRecodeMsg {
  return { page: 0, count: 0 };
}

export const csMyRecodeMsg: MessageFns<csMyRecodeMsg> = {
  encode(message: csMyRecodeMsg, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.page !== 0) {
      writer.uint32(8).int32(message.page);
    }
    if (message.count !== 0) {
      writer.uint32(16).int32(message.count);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): csMyRecodeMsg {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasecsMyRecodeMsg();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.page = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.count = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): csMyRecodeMsg {
    return {
      page: isSet(object.page) ? globalThis.Number(object.page) : 0,
      count: isSet(object.count) ? globalThis.Number(object.count) : 0,
    };
  },

  toJSON(message: csMyRecodeMsg): unknown {
    const obj: any = {};
    if (message.page !== 0) {
      obj.page = Math.round(message.page);
    }
    if (message.count !== 0) {
      obj.count = Math.round(message.count);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<csMyRecodeMsg>, I>>(base?: I): csMyRecodeMsg {
    return csMyRecodeMsg.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<csMyRecodeMsg>, I>>(object: I): csMyRecodeMsg {
    const message = createBasecsMyRecodeMsg();
    message.page = object.page ?? 0;
    message.count = object.count ?? 0;
    return message;
  },
};

function createBasemyRecodeData(): myRecodeData {
  return { name: "", money: 0 };
}

export const myRecodeData: MessageFns<myRecodeData> = {
  encode(message: myRecodeData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.money !== 0) {
      writer.uint32(16).int32(message.money);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): myRecodeData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasemyRecodeData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.money = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): myRecodeData {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      money: isSet(object.money) ? globalThis.Number(object.money) : 0,
    };
  },

  toJSON(message: myRecodeData): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.money !== 0) {
      obj.money = Math.round(message.money);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<myRecodeData>, I>>(base?: I): myRecodeData {
    return myRecodeData.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<myRecodeData>, I>>(object: I): myRecodeData {
    const message = createBasemyRecodeData();
    message.name = object.name ?? "";
    message.money = object.money ?? 0;
    return message;
  },
};

function createBasescMyRecodeMsg(): scMyRecodeMsg {
  return { data: [] };
}

export const scMyRecodeMsg: MessageFns<scMyRecodeMsg> = {
  encode(message: scMyRecodeMsg, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.data) {
      myRecodeData.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): scMyRecodeMsg {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasescMyRecodeMsg();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.data.push(myRecodeData.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): scMyRecodeMsg {
    return {
      data: globalThis.Array.isArray(object?.data) ? object.data.map((e: any) => myRecodeData.fromJSON(e)) : [],
    };
  },

  toJSON(message: scMyRecodeMsg): unknown {
    const obj: any = {};
    if (message.data?.length) {
      obj.data = message.data.map((e) => myRecodeData.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<scMyRecodeMsg>, I>>(base?: I): scMyRecodeMsg {
    return scMyRecodeMsg.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<scMyRecodeMsg>, I>>(object: I): scMyRecodeMsg {
    const message = createBasescMyRecodeMsg();
    message.data = object.data?.map((e) => myRecodeData.fromPartial(e)) || [];
    return message;
  },
};

function createBasescGetAllMoneyMsg(): scGetAllMoneyMsg {
  return { money: 0 };
}

export const scGetAllMoneyMsg: MessageFns<scGetAllMoneyMsg> = {
  encode(message: scGetAllMoneyMsg, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.money !== 0) {
      writer.uint32(8).int64(message.money);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): scGetAllMoneyMsg {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasescGetAllMoneyMsg();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.money = longToNumber(reader.int64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): scGetAllMoneyMsg {
    return { money: isSet(object.money) ? globalThis.Number(object.money) : 0 };
  },

  toJSON(message: scGetAllMoneyMsg): unknown {
    const obj: any = {};
    if (message.money !== 0) {
      obj.money = Math.round(message.money);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<scGetAllMoneyMsg>, I>>(base?: I): scGetAllMoneyMsg {
    return scGetAllMoneyMsg.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<scGetAllMoneyMsg>, I>>(object: I): scGetAllMoneyMsg {
    const message = createBasescGetAllMoneyMsg();
    message.money = object.money ?? 0;
    return message;
  },
};

function createBasescNewHelpMsg(): scNewHelpMsg {
  return { name: "", counts: 0 };
}

export const scNewHelpMsg: MessageFns<scNewHelpMsg> = {
  encode(message: scNewHelpMsg, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.counts !== 0) {
      writer.uint32(16).int32(message.counts);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): scNewHelpMsg {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasescNewHelpMsg();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.counts = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): scNewHelpMsg {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      counts: isSet(object.counts) ? globalThis.Number(object.counts) : 0,
    };
  },

  toJSON(message: scNewHelpMsg): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.counts !== 0) {
      obj.counts = Math.round(message.counts);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<scNewHelpMsg>, I>>(base?: I): scNewHelpMsg {
    return scNewHelpMsg.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<scNewHelpMsg>, I>>(object: I): scNewHelpMsg {
    const message = createBasescNewHelpMsg();
    message.name = object.name ?? "";
    message.counts = object.counts ?? 0;
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function longToNumber(int64: { toString(): string }): number {
  const num = globalThis.Number(int64.toString());
  if (num > globalThis.Number.MAX_SAFE_INTEGER) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (num < globalThis.Number.MIN_SAFE_INTEGER) {
    throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return num;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
